/**
 * Ultimate Links Page Handler (Fixed)
 * Handles link reordering and visibility restrictions with improved security
 */

// Configuration
const LINKS_CONFIG = {
  // Time in milliseconds to refresh link ordering (3 hours)
  LINK_REFRESH_INTERVAL: 3 * 60 * 60 * 1000,
  // Number of free links per category
  FREE_LINKS_COUNT: 3
};

// Initialize links page handler
function initLinksPageHandler() {
  // Check if this is the ultimate links page
  if (window.location.pathname !== '/ultimate-links.html') return;
  
  // Wait for links to be loaded
  const linksContent = document.getElementById('linksContent');
  if (!linksContent) return;
  
  // Check login status
  const loggedIn = typeof isLoggedIn === 'function' ? isLoggedIn() : false;
  
  // Check if we need to reorder links (every 3 hours)
  const lastReorderTime = localStorage.getItem('lastLinksReorderTime');
  const now = new Date().getTime();
  
  if (!lastReorderTime || (now - parseInt(lastReorderTime)) > LINKS_CONFIG.LINK_REFRESH_INTERVAL) {
    // Time to reorder links
    reorderCategoryLinks();
    localStorage.setItem('lastLinksReorderTime', now.toString());
  }
  
  // If not logged in, limit visible links
  if (!loggedIn) {
    limitVisibleLinks();
  }
}

// Reorder links within each category
function reorderCategoryLinks() {
  const categories = document.querySelectorAll('.category');
  
  categories.forEach(category => {
    const linksGrid = category.querySelector('.links-grid');
    if (!linksGrid) return;
    
    const links = Array.from(linksGrid.querySelectorAll('.link-item'));
    
    // Save original links order in localStorage for restoration if needed
    const categoryId = category.querySelector('.category-title').textContent.trim();
    const originalOrder = links.map(link => {
      const linkText = link.querySelector('.link-text')?.textContent || '';
      return linkText;
    });
    
    try {
      localStorage.setItem(`originalLinksOrder_${categoryId}`, JSON.stringify(originalOrder));
    } catch (e) {
      console.error('Error saving original links order:', e);
    }
    
    // Shuffle links
    const shuffledLinks = shuffleArray(links);
    
    // Clear and re-add links in new order
    linksGrid.innerHTML = '';
    shuffledLinks.forEach(link => {
      linksGrid.appendChild(link);
    });
  });
}

// Fisher-Yates shuffle algorithm
function shuffleArray(array) {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
}

// Generate a random fake URL
function generateRandomURL() {
  const protocols = ['https://', 'http://'];
  const domains = ['example.com', 'test.org', 'placeholder.net', 'sample.io', 'domain.site'];
  const paths = ['page', 'index', 'main', 'home', 'about', 'contact', 'services', 'blog', 'info'];
  const extensions = ['html', 'php', 'aspx', 'jsp'];
  
  const protocol = protocols[Math.floor(Math.random() * protocols.length)];
  const domain = domains[Math.floor(Math.random() * domains.length)];
  const numPaths = Math.floor(Math.random() * 3) + 1;
  let url = protocol + 'www.' + domain;
  
  for (let i = 0; i < numPaths; i++) {
    const path = paths[Math.floor(Math.random() * paths.length)];
    url += '/' + path;
  }
  
  // Add random extension
  if (Math.random() > 0.5) {
    const extension = extensions[Math.floor(Math.random() * extensions.length)];
    url += '.' + extension;
  }
  
  // Add random query parameters
  if (Math.random() > 0.7) {
    url += '?id=' + Math.floor(Math.random() * 10000);
    if (Math.random() > 0.5) {
      url += '&page=' + Math.floor(Math.random() * 100);
    }
  }
  
  return url;
}

// Limit visible links to FREE_LINKS_COUNT per category - Fixed version with random URLs
function limitVisibleLinks() {
  const categories = document.querySelectorAll('.category');
  
  categories.forEach(category => {
    const linksGrid = category.querySelector('.links-grid');
    if (!linksGrid) return;
    
    const links = linksGrid.querySelectorAll('.link-item');
    
    // Process each link
    links.forEach((link, index) => {
      if (index >= LINKS_CONFIG.FREE_LINKS_COUNT) {
        // Only process if not already locked
        if (link.parentNode.className !== 'locked-link-container') {
          // Create a container div for the locked link
          const lockContainer = document.createElement('div');
          lockContainer.className = 'locked-link-container';
          lockContainer.style.position = 'relative';
          lockContainer.style.borderRadius = '8px';
          lockContainer.style.overflow = 'hidden';
          lockContainer.style.cursor = 'pointer';
          lockContainer.style.width = '100%';
          lockContainer.style.margin = '15px 0';
          lockContainer.style.display = 'block';
          
          // Create a completely new fake link instead of cloning the real one
          const fakeLink = document.createElement('div');
          fakeLink.className = 'link-item';
          fakeLink.style.filter = 'blur(5px)';
          fakeLink.style.pointerEvents = 'none';
          fakeLink.style.userSelect = 'none';
          fakeLink.style.margin = '0';
          fakeLink.style.display = 'flex';
          fakeLink.style.alignItems = 'center';
          
          // Add link icon (same as real links)
          const linkIcon = document.createElement('i');
          linkIcon.className = 'fa-solid fa-link link-icon';
          linkIcon.style.marginRight = '10px';
          linkIcon.style.color = '#de5c34';
          linkIcon.style.fontSize = '1.2rem';
          linkIcon.style.flexShrink = '0';
          
          // Create random link text (different from real content)
          const linkText = document.createElement('span');
          linkText.className = 'link-text';
          linkText.textContent = generateRandomURL();
          
          // Assemble fake link
          fakeLink.appendChild(linkIcon);
          fakeLink.appendChild(linkText);
          
          // Add to container
          lockContainer.appendChild(fakeLink);
          
          // Add lock icon
          const lockIcon = document.createElement('div');
          lockIcon.className = 'locked-link-icon';
          lockIcon.innerHTML = '<i class="fa-solid fa-lock"></i>';
          lockIcon.style.position = 'absolute';
          lockIcon.style.top = '50%';
          lockIcon.style.left = '50%';
          lockIcon.style.transform = 'translate(-50%, -50%)';
          lockIcon.style.color = 'white';
          lockIcon.style.fontSize = '24px';
          lockIcon.style.zIndex = '10';
          lockIcon.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
          lockIcon.style.borderRadius = '50%';
          lockIcon.style.width = '40px';
          lockIcon.style.height = '40px';
          lockIcon.style.display = 'flex';
          lockIcon.style.justifyContent = 'center';
          lockIcon.style.alignItems = 'center';
          
          lockContainer.appendChild(lockIcon);
          
          // Add click event for login popup
          lockContainer.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Show login popup
            if (typeof showLoginPopup === 'function') {
              showLoginPopup();
            } else {
              window.location.href = '/login.html';
            }
          });
          
          // Replace original link with the locked container
          link.replaceWith(lockContainer);
        }
      }
    });
  });
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  // Add a slight delay to ensure the page is fully loaded
  setTimeout(initLinksPageHandler, 100);
});

// Also run when window is fully loaded (for dynamic content)
window.addEventListener('load', () => {
  setTimeout(initLinksPageHandler, 500);
});

// Handle search functionality
document.addEventListener('DOMContentLoaded', () => {
  const searchInput = document.getElementById('searchInput');
  if (!searchInput) return;
  
  // Add event listener to reapply locks after search
  searchInput.addEventListener('input', () => {
    // Check login status
    const loggedIn = typeof isLoggedIn === 'function' ? isLoggedIn() : false;
    
    if (!loggedIn) {
      // Wait for search results to update
      setTimeout(() => {
        limitVisibleLinks();
      }, 100);
    }
  });
});

// Handle DOM mutations to catch dynamically added content
document.addEventListener('DOMContentLoaded', () => {
  // Check if this is the ultimate links page
  if (window.location.pathname !== '/ultimate-links.html') return;
  
  // Use MutationObserver to detect when links are added
  const observer = new MutationObserver(mutations => {
    mutations.forEach(mutation => {
      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
        // Check login status
        const loggedIn = typeof isLoggedIn === 'function' ? isLoggedIn() : false;
        
        if (!loggedIn) {
          // Reapply link limits
          setTimeout(limitVisibleLinks, 50);
        }
      }
    });
  });
  
  // Start observing the document with the configured parameters
  observer.observe(document.body, { childList: true, subtree: true });
});