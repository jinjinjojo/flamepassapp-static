/**
 * RELATED GAMES SECTION UPDATES
 */

// Update games from the same category
function updateCategoryBasedGames(game, allGames, category) {
  if (!game || !allGames || !category) return;

  // Create container if not exists
  let container = document.querySelector('.category-games-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'category-games-container';

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // Filter games from the same category, but not the current game
  const categoryGames = allGames.filter(g =>
    g.category === category && g.slug !== game.slug
  );

  // If no games, hide container
  if (categoryGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games from category (up to 4)
  const gamesToShow = getRandomGames(categoryGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';
  header.innerHTML = `
    <h2>More ${category.charAt(0).toUpperCase() + category.slice(1)} Games</h2>
    <a href="/g.html?category=${category}" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}

// Document ready event - This is already implemented at the top of the file
// We keep the code modular and initialized via the DOMContentLoaded event


// Update trending games section
function updateTrendingGames(allGames) {
  if (!allGames) return;

  // Create container if not exists
  let container = document.querySelector('.trending-games-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'trending-games-container';

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // If no games, hide container
  if (allGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games (up to 4) - in a real app, this would be most popular
  const gamesToShow = getRandomGames(allGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';
  header.innerHTML = `
    <h2>Trending Games</h2>
    <a href="/g.html?trending=true" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}

// Update games for specific category
function updateCategoryGames(game, allGames, category) {
  if (!game || !allGames || !category) return;

  // Create container if not exists
  let container = document.querySelector(`.${category}-games-container`);
  if (!container) {
    container = document.createElement('div');
    container.className = `${category}-games-container`;

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // Filter games from the specific category, but not the current game
  const categoryGames = allGames.filter(g =>
    g.category === category && g.slug !== game.slug
  );

  // If no games, hide container
  if (categoryGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games from category (up to 4)
  const gamesToShow = getRandomGames(categoryGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';

  // Customize title based on category
  let title;
  switch (category) {
    case 'browser':
      title = 'HTML5 Browser Games';
      break;
    case 'emulator':
      title = 'Emulator Games';
      break;
    case 'cloud':
      title = 'Cloud Gaming';
      break;
    default:
      title = `${category.charAt(0).toUpperCase() + category.slice(1)} Games`;
  }

  header.innerHTML = `
    <h2>${title}</h2>
    <a href="/g.html?category=${category}" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}/**
 * Enhanced Game Page Handler
 * Works with both server-side rendering and client-side rendering
 */

  document.addEventListener('DOMContentLoaded', () => {
    // Check if we're on a game page
    if (window.location.pathname.startsWith('/game/')) {
      // Check if we have server-rendered game data
      if (window.currentGame && window.currentGame.slug) {
        console.log('Using server-rendered game data:', window.currentGame);
        // Initialize just the dynamic parts since the page is already server-rendered
        initializeDynamicComponents(window.currentGame);
      } else {
        // Fall back to client-side rendering
        const slug = window.location.pathname.split('/').pop();
        initGamePage(slug);
      }
    }

    // Initialize the search functionality
    initSearch();

    // Initialize the scroll to top button
    initScrollToTop();

    // Setup keyboard shortcuts
    setupKeyboardShortcuts();

    // Initialize particles.js if available
    initializeParticles();
  });

  /**
   * UI UTILITY FUNCTIONS
   */

  // Function to initialize the scroll to top button
  function initScrollToTop() {
    const scrollTopBtn = document.getElementById('scrollTopBtn');

    if (!scrollTopBtn) return;

    // Show/hide button based on scroll position
    window.addEventListener('scroll', () => {
      if (document.documentElement.scrollTop > 300) {
        scrollTopBtn.classList.add('visible');
      } else {
        scrollTopBtn.classList.remove('visible');
      }
    });

    // Scroll to top when clicked
    scrollTopBtn.addEventListener('click', () => {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    });
  }

  // Function to setup keyboard shortcuts
  function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      // Open search with Cmd+K or Ctrl+K
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        openSearchModal();
      }

      // Close search with Escape
      if (e.key === 'Escape') {
        closeSearchModal();

        // Also close auth modal if open
        const authModal = document.getElementById('authModal');
        if (authModal && authModal.classList.contains('active')) {
          authModal.classList.remove('active');
        }
      }
    });
  }

  /**
   * SEARCH FUNCTIONALITY
   */

  // Function to initialize search functionality
  function initSearch() {
    const searchTrigger = document.getElementById('searchTrigger');
    const searchModal = document.getElementById('searchModal');
    const closeSearch = document.getElementById('closeSearch');
    const searchInput = document.getElementById('searchInput');
    const searchResults = document.getElementById('searchResults');

    if (!searchTrigger || !searchModal || !closeSearch || !searchInput || !searchResults) {
      console.warn('Search elements not found. Search functionality disabled.');
      return;
    }

    // Open search modal
    searchTrigger.addEventListener('click', () => {
      openSearchModal();
    });

    // Close search modal
    closeSearch.addEventListener('click', () => {
      closeSearchModal();
    });

    // Click outside to close
    searchModal.addEventListener('click', (e) => {
      if (e.target === searchModal) {
        closeSearchModal();
      }
    });

    // Search input handler with debounce
    let debounceTimer;
    searchInput.addEventListener('input', () => {
      clearTimeout(debounceTimer);

      const query = searchInput.value.trim();

      if (query.length < 2) {
        searchResults.innerHTML = `
        <div class="search-message">
          <span class="material-symbols-outlined">search</span>
          <p>Type at least 2 characters to search</p>
        </div>
      `;
        return;
      }

      // Set loading state
      searchResults.innerHTML = `
      <div class="search-message">
        <div class="loader" style="width: 30px; height: 30px;">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="32" class="loader-circle" />
          </svg>
        </div>
        <p>Searching...</p>
      </div>
    `;

      // Debounce search request
      debounceTimer = setTimeout(() => {
        performSearch(query.toLowerCase());
      }, 300);
    });
  }

  // Function to open search modal
  function openSearchModal() {
    const searchModal = document.getElementById('searchModal');
    const searchInput = document.getElementById('searchInput');

    if (!searchModal || !searchInput) return;

    searchModal.classList.add('active');

    // Focus input after animation
    setTimeout(() => {
      searchInput.focus();
    }, 100);

    // Disable body scroll
    document.body.style.overflow = 'hidden';
  }

  // Function to close search modal
  function closeSearchModal() {
    const searchModal = document.getElementById('searchModal');
    const searchInput = document.getElementById('searchInput');

    if (!searchModal || !searchInput) return;

    searchModal.classList.remove('active');
    searchInput.value = '';

    // Enable body scroll
    document.body.style.overflow = '';
  }

  // Function to perform search
  async function performSearch(query) {
    const searchResults = document.getElementById('searchResults');

    if (!searchResults) return;

    try {
      // Get all games
      const allGames = await fetchGames();

      console.log(`Searching through ${allGames.length} games for "${query}"`);

      // Filter games based on query
      const filteredGames = allGames.filter(game =>
        (game.name && game.name.toLowerCase().includes(query)) ||
        (game.description && game.description.toLowerCase().includes(query)) ||
        (game.category && game.category.toLowerCase().includes(query)) ||
        (game.publisher && game.publisher.toLowerCase().includes(query)) ||
        (game.tags && Array.isArray(game.tags) && game.tags.some(tag => tag.toLowerCase().includes(query)))
      );

      // Display results
      if (filteredGames.length === 0) {
        searchResults.innerHTML = `
        <div class="search-message">
          <span class="material-symbols-outlined">sentiment_dissatisfied</span>
          <p>No games found matching "${query}"</p>
        </div>
      `;
      } else {
        searchResults.innerHTML = '';

        filteredGames.slice(0, 8).forEach(game => {
          const resultItem = document.createElement('a');
          resultItem.href = `/game/${game.slug}`;
          resultItem.className = 'search-result-item';

          resultItem.innerHTML = `
          <div class="search-result-image">
            <img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" loading="lazy">
          </div>
          <div class="search-result-info">
            <h3>${game.name}</h3>
            <div class="search-result-meta">
              <span class="category-pill">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser Game'}</span>
              ${game.publisher ? `<span class="publisher">${game.publisher}</span>` : ''}
            </div>
          </div>
        `;

          searchResults.appendChild(resultItem);
        });

        if (filteredGames.length > 8) {
          const viewAll = document.createElement('a');
          viewAll.href = `/g.html?search=${encodeURIComponent(query)}`;
          viewAll.className = 'view-all-results';
          viewAll.innerHTML = `View all ${filteredGames.length} results <span class="material-symbols-outlined">arrow_forward</span>`;
          searchResults.appendChild(viewAll);
        }
      }
    } catch (error) {
      console.error('Error during search:', error);
      searchResults.innerHTML = `
      <div class="search-message">
        <span class="material-symbols-outlined">error</span>
        <p>An error occurred while searching</p>
      </div>
    `;
    }
  }

  /**
   * DATA FETCHING AND UTILITIES
   */

  // Function to fetch games data from various sources
  async function fetchGames() {
    // Try to get from window cache first (may be set by other scripts)
    if (window.allGames && Array.isArray(window.allGames) && window.allGames.length > 0) {
      return window.allGames;
    }

    // Try to get from memory cache
    if (window.cache && window.cache.games && Array.isArray(window.cache.games)) {
      return window.cache.games;
    }

    // Try each category cache
    const categories = ['cloud', 'browser', 'emulator'];
    let allGames = [];

    for (const category of categories) {
      if (window.cache && window.cache[category] && Array.isArray(window.cache[category])) {
        allGames = [...allGames, ...window.cache[category]];
      } else {
        // Try localStorage
        try {
          const cachedData = localStorage.getItem(`cache_games_${category}`);
          if (cachedData) {
            const parsed = JSON.parse(cachedData);
            if (parsed.data && Array.isArray(parsed.data)) {
              allGames = [...allGames, ...parsed.data];
            }
          }
        } catch (e) {
          console.warn(`Error loading ${category} games from localStorage:`, e);
        }
      }
    }

    // If we have games, return them
    if (allGames.length > 0) {
      return allGames;
    }

    // Try to get from IndexedDB
    try {
      const db = await openIndexedDB();
      if (db) {
        const games = await getAllGamesFromDB(db);
        if (games && games.length > 0) {
          return games;
        }
      }
    } catch (e) {
      console.warn('Error loading games from IndexedDB:', e);
    }

    // Last resort: try to get from legacy cache
    try {
      const cachedData = localStorage.getItem('cache_games');
      if (cachedData) {
        const parsed = JSON.parse(cachedData);
        if (parsed.data && Array.isArray(parsed.data)) {
          return parsed.data;
        }
      }
    } catch (e) {
      console.warn('Error loading games from legacy cache:', e);
    }

    // If all else fails, fetch from server
    try {
      const response = await fetch('/json/g.json');
      if (!response.ok) throw new Error('Failed to fetch games data');

      const data = await response.json();

      // Add some sample data for publisher and releaseDate for cloud games
      // (This would come from the server in a real implementation)
      const enhancedData = data.map(game => {
        if (game.category === 'cloud' && !game.publisher) {
          // Add publisher and release date for cloud games
          const publishers = [
            'Epic Games', 'Activision', 'EA Games', 'Ubisoft',
            'Rockstar Games', 'Valve', 'Bethesda', 'Square Enix',
            'Nintendo', 'Sony Interactive', 'Blizzard', 'Sega'
          ];

          const dates = [
            'Jan 2023', 'Mar 2023', 'Sep 2022', 'Dec 2022',
            'May 2022', 'Oct 2021', 'Feb 2022', 'Apr 2023',
            'Nov 2022', 'Aug 2022', 'Jun 2023', 'Jul 2022'
          ];

          // Generate a deterministic but seemingly random publisher and date
          const index = game.name.length % publishers.length;
          return {
            ...game,
            publisher: publishers[index],
            releaseDate: dates[index]
          };
        }
        return game;
      });

      return enhancedData;
    } catch (error) {
      console.error('Error fetching games data:', error);
      return [];
    }
  }

  // Helper function to open IndexedDB
  function openIndexedDB() {
    return new Promise((resolve, reject) => {
      if (!window.indexedDB) {
        resolve(null);
        return;
      }

      const request = indexedDB.open('flamepass_games', 1);

      request.onerror = event => {
        console.error('IndexedDB error:', event.target.error);
        resolve(null);
      };

      request.onsuccess = event => {
        resolve(event.target.result);
      };

      request.onupgradeneeded = event => {
        const db = event.target.result;

        if (!db.objectStoreNames.contains('games')) {
          db.createObjectStore('games', { keyPath: 'slug' });
        }

        if (!db.objectStoreNames.contains('meta')) {
          db.createObjectStore('meta', { keyPath: 'key' });
        }
      };
    });
  }

  // Helper function to get all games from IndexedDB
  function getAllGamesFromDB(db) {
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['games'], 'readonly');
      const store = transaction.objectStore('games');
      const request = store.getAll();

      request.onsuccess = event => {
        resolve(event.target.result);
      };

      request.onerror = event => {
        console.error('Error getting games from IndexedDB:', event.target.error);
        resolve([]);
      };
    });
  }

  // Helper function to get random games
  function getRandomGames(games, count) {
    if (!Array.isArray(games) || games.length === 0) {
      return [];
    }

    // Shuffle array
    const shuffled = [...games].sort(() => 0.5 - Math.random());

    // Return up to count games
    return shuffled.slice(0, Math.min(count, shuffled.length));
  }

  /**
   * GAME PAGE INITIALIZATION (fallback for client-side rendering)
   */

  // Initialize the game page
  async function initGamePage(slug) {
    if (!slug) return;

    try {
      // Show loading state
      showLoading();

      // Get game data
      const allGames = await fetchGames();
      const currentGame = allGames.find(game => game.slug === slug);

      // Store game data globally for other scripts
      window.currentGame = currentGame;
      window.allGames = allGames;

      if (!currentGame) {
        showError('Game Not Found', 'Sorry, we couldn\'t find the game you\'re looking for.');
        return;
      }

      // Update game details in the existing container
      const gameContainer = document.getElementById('game-container');
      if (gameContainer) {
        updateGameDetails(currentGame, allGames);
      }

      // Initialize components with all categories
      const categories = ['browser', 'emulator', 'cloud'];
      const currentCategory = currentGame.category || 'browser';

      // First show games from the same category
      updateCategoryBasedGames(currentGame, allGames, currentCategory);

      // Then show trending games
      updateTrendingGames(allGames);

      // Then show games from other categories
      categories.forEach(category => {
        if (category !== currentCategory) {
          updateCategoryGames(currentGame, allGames, category);
        }
      });

    } catch (error) {
      console.error('Error initializing game page:', error);
      showError('Error Loading Game', 'There was a problem loading the game details. Please try again later.');
    }
  }

  // Show loading state
  function showLoading() {
    const gameContainer = document.getElementById('game-container');
    if (!gameContainer) return;

    // Create a loading indicator inside the first element of game container
    const firstElement = gameContainer.firstElementChild;
    if (firstElement) {
      firstElement.innerHTML = `
      <div class="loading-container">
        <div class="loader">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="32" class="loader-circle"></circle>
          </svg>
        </div>
        <div class="loading-text">Loading game details...</div>
      </div>
    `;
    }
  }

  // Show error message
  function showError(title, message) {
    const gameContainer = document.getElementById('game-container');
    if (!gameContainer) return;

    // Update the first element with error message
    const firstElement = gameContainer.firstElementChild;
    if (firstElement) {
      firstElement.innerHTML = `
      <div class="error-message">
        <span class="material-symbols-outlined">error</span>
        <h3>${title}</h3>
        <p>${message}</p>
        <a href="/g.html" class="retry-button">
          <i class="fa-solid fa-gamepad"></i>
          Browse All Games
        </a>
      </div>
    `;
    }
  }

  /**
   * Initialize dynamic components for server-rendered pages
   */
  function initializeDynamicComponents(currentGame) {
    // Initialize parallax effect
    initParallaxEffect();

    // Add event listeners to buttons
    setupButtonHandlers(currentGame);

    // Setup cloud provider buttons if applicable
    setupCloudProviderButtons();

    // Fetch all games for related content
    fetchGames().then(allGames => {
      // Store games data for other scripts
      window.allGames = allGames;

      // Update related games sections based on categories
      const categories = ['browser', 'emulator', 'cloud'];
      const currentCategory = currentGame.category || 'browser';

      // First show games from the same category
      updateCategoryBasedGames(currentGame, allGames, currentCategory);

      // Then show trending games
      updateTrendingGames(allGames);

      // Then show games from other categories
      categories.forEach(category => {
        if (category !== currentCategory) {
          updateCategoryGames(currentGame, allGames, category);
        }
      });

    }).catch(error => {
      console.error('Error fetching games for dynamic components:', error);
    });
  }
  /**
 * Fix for missing functions in game-page-handler.min.js
 * These functions need to be added to fix the errors
 * 
 * Main issues fixed:
 * 1. Missing initializeParticles function
 * 2. Missing updateGameDetails function
 * 3. Missing setupCloudProviderButtons function
 * 4. Proper handling of cloud games vs browser/emulator games
 */

// Function to initialize particles.js effect
function initializeParticles() {
  // This function is called in the DOMContentLoaded event handler
  // We can reuse the implementation from paste-5.txt
  if (window.particlesJS && document.getElementById('particles-js')) {
    particlesJS('particles-js', {
      particles: {
        number: { value: 80, density: { enable: true, value_area: 800 } },
        color: { value: '#ffffff' },
        shape: { type: 'circle' },
        opacity: { value: 0.5, random: true },
        size: { value: 3, random: true },
        line_linked: { enable: false },
        move: {
          enable: true,
          speed: 0.3,
          direction: 'top',
          random: true,
          straight: false,
          out_mode: 'out'
        }
      }
    });
  }
}

// Function to update game details - this should be added before initGamePage is called
function updateGameDetails(game, allGames) {
  if (!game) return;
  
  const gameContainer = document.getElementById('game-container');
  const gameInfoSection = gameContainer.querySelector('.game-info');
  
  if (!gameInfoSection) return;
  
  // Clear any loading state
  gameInfoSection.innerHTML = '';
  
  // Create game header with background image
  const headerSection = document.createElement('div');
  headerSection.className = 'game-header';
  headerSection.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.8)), url('${game.img || '/assets/game-placeholder.jpg'}')`;
  
  const headerContent = document.createElement('div');
  headerContent.className = 'header-content';
  
  // Game image
  const gameImage = document.createElement('div');
  gameImage.className = 'game-image';
  gameImage.innerHTML = `<img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" loading="lazy">`;
  
  // Game title and details
  const gameDetails = document.createElement('div');
  gameDetails.className = 'game-details';
  
  const title = document.createElement('h1');
  title.textContent = game.name;
  
  const category = document.createElement('div');
  category.className = 'game-category';
  category.innerHTML = `<span class="category-pill">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser'}</span>`;
  
  // Add publisher and release date if available
  if (game.publisher || game.releaseDate) {
    const metadata = document.createElement('div');
    metadata.className = 'game-metadata';
    
    if (game.publisher) {
      metadata.innerHTML += `<span class="publisher">Publisher: ${game.publisher}</span>`;
    }
    
    if (game.releaseDate) {
      metadata.innerHTML += `<span class="release-date">Released: ${game.releaseDate}</span>`;
    }
    
    gameDetails.appendChild(metadata);
  }
  
  // Add tags if available
  if (game.tags && Array.isArray(game.tags) && game.tags.length > 0) {
    const tags = document.createElement('div');
    tags.className = 'game-tags';
    
    game.tags.forEach(tag => {
      const tagSpan = document.createElement('span');
      tagSpan.className = 'tag';
      tagSpan.textContent = tag;
      tags.appendChild(tagSpan);
    });
    
    gameDetails.appendChild(tags);
  }
  
  // Add description if available
  if (game.description) {
    const description = document.createElement('div');
    description.className = 'game-description';
    description.innerHTML = `<p>${game.description}</p>`;
    gameDetails.appendChild(description);
  }
  
  // Append elements to header
  gameDetails.prepend(category);
  gameDetails.prepend(title);
  headerContent.appendChild(gameImage);
  headerContent.appendChild(gameDetails);
  headerSection.appendChild(headerContent);
  
  // Create action buttons based on game category
  const actionButtons = document.createElement('div');
  actionButtons.className = 'game-action-buttons';
  
  // Different button approach for cloud games vs browser/emulator games
  if (game.category === 'cloud' && game.serviceProviders) {
    // Set up cloud providers - don't add play buttons for cloud games
    setupCloudProviders(game);
  } else {
    // Standard play buttons for browser and emulator games
    
    // Direct play button
    const playButton = document.createElement('a');
    playButton.href = game.url;
    playButton.className = 'play-button primary-button';
    playButton.target = '_blank';
    playButton.innerHTML = `
      <span class="material-symbols-outlined">play_arrow</span>
      Play Now
    `;
    
    // Proxy play button
    const proxyButton = document.createElement('a');
    proxyButton.href = `/&.html?url=${encodeURIComponent(game.url)}`;
    proxyButton.className = 'play-button secondary-button';
    proxyButton.target = '_blank';
    proxyButton.innerHTML = `
      <span class="material-symbols-outlined">security</span>
      Play with Flamepass Proxy
    `;
    
    // Append buttons
    actionButtons.appendChild(playButton);
    actionButtons.appendChild(proxyButton);
    
    // Add favorite button (functionality would be added separately)
    const favoriteButton = document.createElement('button');
    favoriteButton.className = 'favorite-button';
    favoriteButton.innerHTML = `<span class="material-symbols-outlined">favorite_border</span>`;
    actionButtons.appendChild(favoriteButton);
  }
  
  // Add action buttons to header content
  headerContent.appendChild(actionButtons);
  
  // Append the whole header section to the game info
  gameInfoSection.appendChild(headerSection);
}

// Function to set up cloud gaming providers
function setupCloudProviders(game) {
  if (!game || !game.serviceProviders) return;
  
  const providersContainer = document.getElementById('cloud-providers-container');
  const providersGrid = document.getElementById('providers-grid');
  
  if (!providersContainer || !providersGrid) return;
  
  // Clear existing providers
  providersGrid.innerHTML = '';
  
  // Loop through each service provider
  Object.entries(game.serviceProviders).forEach(([provider, details]) => {
    const providerCard = document.createElement('div');
    providerCard.className = 'provider-card';
    
    // Provider logo
    const logoPath = `/assets/providers/${provider.toLowerCase()}.png`;
    
    // Provider info and buttons
    providerCard.innerHTML = `
      <div class="provider-info">
        <img src="${logoPath}" alt="${provider}" class="provider-logo">
        <h3>${provider}</h3>
      </div>
      <div class="provider-buttons">
        <a href="${details.url}" target="_blank" class="provider-button direct">
          <span class="material-symbols-outlined">launch</span>
          Open Directly
        </a>
        <a href="/&.html?url=${encodeURIComponent(details.url)}" target="_blank" class="provider-button proxy">
          <span class="material-symbols-outlined">security</span>
          Use Proxy
        </a>
      </div>
    `;
    
    providersGrid.appendChild(providerCard);
  });
  
  // Show the providers section
  providersContainer.style.display = 'block';
}

// Function to setup cloud provider buttons
function setupCloudProviderButtons() {
  // This is a wrapper function that will be called by initializeDynamicComponents
  // The actual functionality is in setupCloudProviders
  const currentGame = window.currentGame;
  if (currentGame && currentGame.category === 'cloud' && currentGame.serviceProviders) {
    setupCloudProviders(currentGame);
  } else {
    // Hide the cloud providers container if not applicable
    const providersContainer = document.getElementById('cloud-providers-container');
    if (providersContainer) {
      providersContainer.style.display = 'none';
    }
  }
}

// Add missing initParallaxEffect function
function initParallaxEffect() {
  // Simple parallax effect for background images
  const gameHeader = document.querySelector('.game-header');
  if (!gameHeader) return;
  
  window.addEventListener('scroll', () => {
    const scrollPosition = window.scrollY;
    if (scrollPosition < 500) { // Limit parallax effect to top of page
      const translateY = scrollPosition * 0.3;
      gameHeader.style.backgroundPosition = `center ${translateY}px`;
    }
  });
}

// Add missing setupButtonHandlers function
function setupButtonHandlers(game) {
  // Handle favorite button clicks
  const favoriteBtn = document.querySelector('.favorite-button');
  if (favoriteBtn) {
    favoriteBtn.addEventListener('click', (e) => {
      e.preventDefault();
      
      // Toggle favorite status
      const isFavorite = favoriteBtn.classList.contains('active');
      
      if (isFavorite) {
        favoriteBtn.classList.remove('active');
        favoriteBtn.querySelector('.material-symbols-outlined').textContent = 'favorite_border';
        // Here you would implement removing from favorites in your storage
      } else {
        favoriteBtn.classList.add('active');
        favoriteBtn.querySelector('.material-symbols-outlined').textContent = 'favorite';
        // Here you would implement adding to favorites in your storage
      }
    });
  }
}

// Update the updateGameGrid function if it's missing
function updateGameGrid(grid, games) {
  if (!grid || !Array.isArray(games)) return;
  
  // Clear grid first
  grid.innerHTML = '';
  
  // Add game cards to grid
  games.forEach(game => {
    const gameCard = document.createElement('a');
    gameCard.href = `/game/${game.slug}`;
    gameCard.className = 'game-card';
    
    gameCard.innerHTML = `
      <div class="game-card-image">
        <img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" loading="lazy">
      </div>
      <div class="game-card-info">
        <h3>${game.name}</h3>
        <div class="game-card-meta">
          <span class="category-pill">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser'}</span>
        </div>
      </div>
    `;
    
    grid.appendChild(gameCard);
  });
}