/**
 * RELATED GAMES SECTION UPDATES
 */

// Update games from the same category
function updateCategoryBasedGames(game, allGames, category) {
  if (!game || !allGames || !category) return;

  // Create container if not exists
  let container = document.querySelector('.category-games-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'category-games-container';

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // Filter games from the same category, but not the current game
  const categoryGames = allGames.filter(g =>
    g.category === category && g.slug !== game.slug
  );

  // If no games, hide container
  if (categoryGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games from category (up to 4)
  const gamesToShow = getRandomGames(categoryGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';
  header.innerHTML = `
    <h2>More ${category.charAt(0).toUpperCase() + category.slice(1)} Games</h2>
    <a href="/g.html?category=${category}" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}

// Document ready event - This is already implemented at the top of the file
// We keep the code modular and initialized via the DOMContentLoaded event


// Update trending games section
function updateTrendingGames(allGames) {
  if (!allGames) return;

  // Create container if not exists
  let container = document.querySelector('.trending-games-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'trending-games-container';

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // If no games, hide container
  if (allGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games (up to 4) - in a real app, this would be most popular
  const gamesToShow = getRandomGames(allGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';
  header.innerHTML = `
    <h2>Trending Games</h2>
    <a href="/g.html?trending=true" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}

// Update games for specific category
function updateCategoryGames(game, allGames, category) {
  if (!game || !allGames || !category) return;

  // Create container if not exists
  let container = document.querySelector(`.${category}-games-container`);
  if (!container) {
    container = document.createElement('div');
    container.className = `${category}-games-container`;

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // Filter games from the specific category, but not the current game
  const categoryGames = allGames.filter(g =>
    g.category === category && g.slug !== game.slug
  );

  // If no games, hide container
  if (categoryGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games from category (up to 4)
  const gamesToShow = getRandomGames(categoryGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';

  // Customize title based on category
  let title;
  switch (category) {
    case 'browser':
      title = 'HTML5 Browser Games';
      break;
    case 'emulator':
      title = 'Emulator Games';
      break;
    case 'cloud':
      title = 'Cloud Gaming';
      break;
    default:
      title = `${category.charAt(0).toUpperCase() + category.slice(1)} Games`;
  }

  header.innerHTML = `
    <h2>${title}</h2>
    <a href="/g.html?category=${category}" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}/**
 * Enhanced Game Page Handler
 * Works with both server-side rendering and client-side rendering
 */

  document.addEventListener('DOMContentLoaded', () => {
    // Check if we're on a game page
    if (window.location.pathname.startsWith('/game/')) {
      // Check if we have server-rendered game data
      if (window.currentGame && window.currentGame.slug) {
        console.log('Using server-rendered game data:', window.currentGame);
        // Initialize just the dynamic parts since the page is already server-rendered
        initializeDynamicComponents(window.currentGame);
      } else {
        // Fall back to client-side rendering
        const slug = window.location.pathname.split('/').pop();
        initGamePage(slug);
      }
    }

    // Initialize the search functionality
    initSearch();

    // Initialize the scroll to top button
    initScrollToTop();

    // Setup keyboard shortcuts
    setupKeyboardShortcuts();

    // Initialize particles.js if available
    initializeParticles();
  });

  /**
   * UI UTILITY FUNCTIONS
   */

  // Function to initialize the scroll to top button
  function initScrollToTop() {
    const scrollTopBtn = document.getElementById('scrollTopBtn');

    if (!scrollTopBtn) return;

    // Show/hide button based on scroll position
    window.addEventListener('scroll', () => {
      if (document.documentElement.scrollTop > 300) {
        scrollTopBtn.classList.add('visible');
      } else {
        scrollTopBtn.classList.remove('visible');
      }
    });

    // Scroll to top when clicked
    scrollTopBtn.addEventListener('click', () => {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    });
  }

  // Function to setup keyboard shortcuts
  function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      // Open search with Cmd+K or Ctrl+K
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        openSearchModal();
      }

      // Close search with Escape
      if (e.key === 'Escape') {
        closeSearchModal();

        // Also close auth modal if open
        const authModal = document.getElementById('authModal');
        if (authModal && authModal.classList.contains('active')) {
          authModal.classList.remove('active');
        }
      }
    });
  }

  /**
   * SEARCH FUNCTIONALITY
   */

  // Function to initialize search functionality
  function initSearch() {
    const searchTrigger = document.getElementById('searchTrigger');
    const searchModal = document.getElementById('searchModal');
    const closeSearch = document.getElementById('closeSearch');
    const searchInput = document.getElementById('searchInput');
    const searchResults = document.getElementById('searchResults');

    if (!searchTrigger || !searchModal || !closeSearch || !searchInput || !searchResults) {
      console.warn('Search elements not found. Search functionality disabled.');
      return;
    }

    // Open search modal
    searchTrigger.addEventListener('click', () => {
      openSearchModal();
    });

    // Close search modal
    closeSearch.addEventListener('click', () => {
      closeSearchModal();
    });

    // Click outside to close
    searchModal.addEventListener('click', (e) => {
      if (e.target === searchModal) {
        closeSearchModal();
      }
    });

    // Search input handler with debounce
    let debounceTimer;
    searchInput.addEventListener('input', () => {
      clearTimeout(debounceTimer);

      const query = searchInput.value.trim();

      if (query.length < 2) {
        searchResults.innerHTML = `
        <div class="search-message">
          <span class="material-symbols-outlined">search</span>
          <p>Type at least 2 characters to search</p>
        </div>
      `;
        return;
      }

      // Set loading state
      searchResults.innerHTML = `
      <div class="search-message">
        <div class="loader" style="width: 30px; height: 30px;">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="32" class="loader-circle" />
          </svg>
        </div>
        <p>Searching...</p>
      </div>
    `;

      // Debounce search request
      debounceTimer = setTimeout(() => {
        performSearch(query.toLowerCase());
      }, 300);
    });
  }

  // Function to open search modal
  function openSearchModal() {
    const searchModal = document.getElementById('searchModal');
    const searchInput = document.getElementById('searchInput');

    if (!searchModal || !searchInput) return;

    searchModal.classList.add('active');

    // Focus input after animation
    setTimeout(() => {
      searchInput.focus();
    }, 100);

    // Disable body scroll
    document.body.style.overflow = 'hidden';
  }

  // Function to close search modal
  function closeSearchModal() {
    const searchModal = document.getElementById('searchModal');
    const searchInput = document.getElementById('searchInput');

    if (!searchModal || !searchInput) return;

    searchModal.classList.remove('active');
    searchInput.value = '';

    // Enable body scroll
    document.body.style.overflow = '';
  }

  // Function to perform search
  async function performSearch(query) {
    const searchResults = document.getElementById('searchResults');

    if (!searchResults) return;

    try {
      // Get all games
      const allGames = await fetchGames();

      console.log(`Searching through ${allGames.length} games for "${query}"`);

      // Filter games based on query
      const filteredGames = allGames.filter(game =>
        (game.name && game.name.toLowerCase().includes(query)) ||
        (game.description && game.description.toLowerCase().includes(query)) ||
        (game.category && game.category.toLowerCase().includes(query)) ||
        (game.publisher && game.publisher.toLowerCase().includes(query)) ||
        (game.tags && Array.isArray(game.tags) && game.tags.some(tag => tag.toLowerCase().includes(query)))
      );

      // Display results
      if (filteredGames.length === 0) {
        searchResults.innerHTML = `
        <div class="search-message">
          <span class="material-symbols-outlined">sentiment_dissatisfied</span>
          <p>No games found matching "${query}"</p>
        </div>
      `;
      } else {
        searchResults.innerHTML = '';

        filteredGames.slice(0, 8).forEach(game => {
          const resultItem = document.createElement('a');
          resultItem.href = `/game/${game.slug}`;
          resultItem.className = 'search-result-item';

          resultItem.innerHTML = `
          <div class="search-result-image">
            <img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" loading="lazy">
          </div>
          <div class="search-result-info">
            <h3>${game.name}</h3>
            <div class="search-result-meta">
              <span class="category-pill">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser Game'}</span>
              ${game.publisher ? `<span class="publisher">${game.publisher}</span>` : ''}
            </div>
          </div>
        `;

          searchResults.appendChild(resultItem);
        });

        if (filteredGames.length > 8) {
          const viewAll = document.createElement('a');
          viewAll.href = `/g.html?search=${encodeURIComponent(query)}`;
          viewAll.className = 'view-all-results';
          viewAll.innerHTML = `View all ${filteredGames.length} results <span class="material-symbols-outlined">arrow_forward</span>`;
          searchResults.appendChild(viewAll);
        }
      }
    } catch (error) {
      console.error('Error during search:', error);
      searchResults.innerHTML = `
      <div class="search-message">
        <span class="material-symbols-outlined">error</span>
        <p>An error occurred while searching</p>
      </div>
    `;
    }
  }

  /**
   * DATA FETCHING AND UTILITIES
   */

  // Function to fetch games data from various sources
  async function fetchGames() {
    // Try to get from window cache first (may be set by other scripts)
    if (window.allGames && Array.isArray(window.allGames) && window.allGames.length > 0) {
      return window.allGames;
    }

    // Try to get from memory cache
    if (window.cache && window.cache.games && Array.isArray(window.cache.games)) {
      return window.cache.games;
    }

    // Try each category cache
    const categories = ['cloud', 'browser', 'emulator'];
    let allGames = [];

    for (const category of categories) {
      if (window.cache && window.cache[category] && Array.isArray(window.cache[category])) {
        allGames = [...allGames, ...window.cache[category]];
      } else {
        // Try localStorage
        try {
          const cachedData = localStorage.getItem(`cache_games_${category}`);
          if (cachedData) {
            const parsed = JSON.parse(cachedData);
            if (parsed.data && Array.isArray(parsed.data)) {
              allGames = [...allGames, ...parsed.data];
            }
          }
        } catch (e) {
          console.warn(`Error loading ${category} games from localStorage:`, e);
        }
      }
    }

    // If we have games, return them
    if (allGames.length > 0) {
      return allGames;
    }

    // Try to get from IndexedDB
    try {
      const db = await openIndexedDB();
      if (db) {
        const games = await getAllGamesFromDB(db);
        if (games && games.length > 0) {
          return games;
        }
      }
    } catch (e) {
      console.warn('Error loading games from IndexedDB:', e);
    }

    // Last resort: try to get from legacy cache
    try {
      const cachedData = localStorage.getItem('cache_games');
      if (cachedData) {
        const parsed = JSON.parse(cachedData);
        if (parsed.data && Array.isArray(parsed.data)) {
          return parsed.data;
        }
      }
    } catch (e) {
      console.warn('Error loading games from legacy cache:', e);
    }

    // If all else fails, fetch from server
    try {
      const response = await fetch('/json/g.json');
      if (!response.ok) throw new Error('Failed to fetch games data');

      const data = await response.json();

      // Add some sample data for publisher and releaseDate for cloud games
      // (This would come from the server in a real implementation)
      const enhancedData = data.map(game => {
        if (game.category === 'cloud' && !game.publisher) {
          // Add publisher and release date for cloud games
          const publishers = [
            'Epic Games', 'Activision', 'EA Games', 'Ubisoft',
            'Rockstar Games', 'Valve', 'Bethesda', 'Square Enix',
            'Nintendo', 'Sony Interactive', 'Blizzard', 'Sega'
          ];

          const dates = [
            'Jan 2023', 'Mar 2023', 'Sep 2022', 'Dec 2022',
            'May 2022', 'Oct 2021', 'Feb 2022', 'Apr 2023',
            'Nov 2022', 'Aug 2022', 'Jun 2023', 'Jul 2022'
          ];

          // Generate a deterministic but seemingly random publisher and date
          const index = game.name.length % publishers.length;
          return {
            ...game,
            publisher: publishers[index],
            releaseDate: dates[index]
          };
        }
        return game;
      });

      return enhancedData;
    } catch (error) {
      console.error('Error fetching games data:', error);
      return [];
    }
  }

  // Helper function to open IndexedDB
  function openIndexedDB() {
    return new Promise((resolve, reject) => {
      if (!window.indexedDB) {
        resolve(null);
        return;
      }

      const request = indexedDB.open('flamepass_games', 1);

      request.onerror = event => {
        console.error('IndexedDB error:', event.target.error);
        resolve(null);
      };

      request.onsuccess = event => {
        resolve(event.target.result);
      };

      request.onupgradeneeded = event => {
        const db = event.target.result;

        if (!db.objectStoreNames.contains('games')) {
          db.createObjectStore('games', { keyPath: 'slug' });
        }

        if (!db.objectStoreNames.contains('meta')) {
          db.createObjectStore('meta', { keyPath: 'key' });
        }
      };
    });
  }

  // Helper function to get all games from IndexedDB
  function getAllGamesFromDB(db) {
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['games'], 'readonly');
      const store = transaction.objectStore('games');
      const request = store.getAll();

      request.onsuccess = event => {
        resolve(event.target.result);
      };

      request.onerror = event => {
        console.error('Error getting games from IndexedDB:', event.target.error);
        resolve([]);
      };
    });
  }

  // Helper function to get random games
  function getRandomGames(games, count) {
    if (!Array.isArray(games) || games.length === 0) {
      return [];
    }

    // Shuffle array
    const shuffled = [...games].sort(() => 0.5 - Math.random());

    // Return up to count games
    return shuffled.slice(0, Math.min(count, shuffled.length));
  }

  /**
   * GAME PAGE INITIALIZATION (fallback for client-side rendering)
   */

  // Initialize the game page
  async function initGamePage(slug) {
    if (!slug) return;

    try {
      // Show loading state
      showLoading();

      // Get game data
      const allGames = await fetchGames();
      const currentGame = allGames.find(game => game.slug === slug);

      // Store game data globally for other scripts
      window.currentGame = currentGame;
      window.allGames = allGames;

      if (!currentGame) {
        showError('Game Not Found', 'Sorry, we couldn\'t find the game you\'re looking for.');
        return;
      }

      // Update game details in the existing container
      const gameContainer = document.getElementById('game-container');
      if (gameContainer) {
        updateGameDetails(currentGame, allGames);
      }

      // Initialize components with all categories
      const categories = ['browser', 'emulator', 'cloud'];
      const currentCategory = currentGame.category || 'browser';

      // First show games from the same category
      updateCategoryBasedGames(currentGame, allGames, currentCategory);

      // Then show trending games
      updateTrendingGames(allGames);

      // Then show games from other categories
      categories.forEach(category => {
        if (category !== currentCategory) {
          updateCategoryGames(currentGame, allGames, category);
        }
      });

    } catch (error) {
      console.error('Error initializing game page:', error);
      showError('Error Loading Game', 'There was a problem loading the game details. Please try again later.');
    }
  }

  // Show loading state
  function showLoading() {
    const gameContainer = document.getElementById('game-container');
    if (!gameContainer) return;

    // Create a loading indicator inside the first element of game container
    const firstElement = gameContainer.firstElementChild;
    if (firstElement) {
      firstElement.innerHTML = `
      <div class="loading-container">
        <div class="loader">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="32" class="loader-circle"></circle>
          </svg>
        </div>
        <div class="loading-text">Loading game details...</div>
      </div>
    `;
    }
  }

  // Show error message
  function showError(title, message) {
    const gameContainer = document.getElementById('game-container');
    if (!gameContainer) return;

    // Update the first element with error message
    const firstElement = gameContainer.firstElementChild;
    if (firstElement) {
      firstElement.innerHTML = `
      <div class="error-message">
        <span class="material-symbols-outlined">error</span>
        <h3>${title}</h3>
        <p>${message}</p>
        <a href="/g.html" class="retry-button">
          <i class="fa-solid fa-gamepad"></i>
          Browse All Games
        </a>
      </div>
    `;
    }
  }

  /**
   * Initialize dynamic components for server-rendered pages
   */
  function initializeDynamicComponents(currentGame) {
    // Initialize parallax effect
    initParallaxEffect();

    // Add event listeners to buttons
    setupButtonHandlers(currentGame);

    // Setup cloud provider buttons if applicable
    setupCloudProviderButtons();

    // Fetch all games for related content
    fetchGames().then(allGames => {
      // Store games data for other scripts
      window.allGames = allGames;

      // Update related games sections based on categories
      const categories = ['browser', 'emulator', 'cloud'];
      const currentCategory = currentGame.category || 'browser';

      // First show games from the same category
      updateCategoryBasedGames(currentGame, allGames, currentCategory);

      // Then show trending games
      updateTrendingGames(allGames);

      // Then show games from other categories
      categories.forEach(category => {
        if (category !== currentCategory) {
          updateCategoryGames(currentGame, allGames, category);
        }
      });

    }).catch(error => {
      console.error('Error fetching games for dynamic components:', error);
    });
  }