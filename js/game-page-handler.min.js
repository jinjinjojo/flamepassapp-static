document.addEventListener('DOMContentLoaded', () => {
  // Check if we're on a game page
  if (window.location.pathname.startsWith('/game/')) {
    // Check if we have server-rendered game data
    if (window.currentGame && window.currentGame.slug) {
      console.log('Using server-rendered game data:', window.currentGame);
      // Initialize just the dynamic parts since the page is already server-rendered
      initializeDynamicComponents(window.currentGame);
    } else {
      // Fall back to client-side rendering
      const slug = window.location.pathname.split('/').pop();
      initGamePage(slug);
    }
  }

  // Initialize the search functionality
  initSearch();

  // Initialize the scroll to top button
  initScrollToTop();

  // Setup keyboard shortcuts
  setupKeyboardShortcuts();

  // Initialize particles.js if available
  initializeParticles();
});
// Helper function to open IndexedDB
function openIndexedDB() {
  return new Promise((resolve, reject) => {
    if (!window.indexedDB) {
      resolve(null);
      return;
    }

    const request = indexedDB.open('flamepass_games', 1);

    request.onerror = event => {
      console.error('IndexedDB error:', event.target.error);
      resolve(null);
    };

    request.onsuccess = event => {
      resolve(event.target.result);
    };

    request.onupgradeneeded = event => {
      const db = event.target.result;

      if (!db.objectStoreNames.contains('games')) {
        db.createObjectStore('games', { keyPath: 'slug' });
      }

      if (!db.objectStoreNames.contains('meta')) {
        db.createObjectStore('meta', { keyPath: 'key' });
      }
    };
  });
}

// Helper function to get all games from IndexedDB
function getAllGamesFromDB(db) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['games'], 'readonly');
    const store = transaction.objectStore('games');
    const request = store.getAll();

    request.onsuccess = event => {
      resolve(event.target.result);
    };

    request.onerror = event => {
      console.error('Error getting games from IndexedDB:', event.target.error);
      resolve([]);
    };
  });
}

// Function to store games in IndexedDB
function storeGamesInDB(db, games) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['games'], 'readwrite');
    const store = transaction.objectStore('games');

    // Clear existing data first
    store.clear();

    // Add all games
    let completed = 0;
    games.forEach(game => {
      const request = store.put(game);
      request.onsuccess = () => {
        completed++;
        if (completed === games.length) {
          // Also store timestamp for cache expiration
          const metaTransaction = db.transaction(['meta'], 'readwrite');
          const metaStore = metaTransaction.objectStore('meta');
          metaStore.put({ key: 'lastUpdate', value: Date.now() });

          resolve();
        }
      };
      request.onerror = event => {
        console.error('Error storing game in IndexedDB:', event.target.error);
        reject(event.target.error);
      };
    });

    transaction.oncomplete = () => {
      console.log('Transaction completed: stored games in IndexedDB');
    };

    transaction.onerror = event => {
      console.error('Transaction error:', event.target.error);
      reject(event.target.error);
    };
  });
}
// Function to fetch games data from various sources
async function fetchGames() {
  // Try to get from window cache first (may be set by other scripts)
  if (window.allGames && Array.isArray(window.allGames) && window.allGames.length > 0) {
    return window.allGames;
  }

  // Try to get from memory cache
  if (window.cache && window.cache.games && Array.isArray(window.cache.games)) {
    return window.cache.games;
  }

  // Try to get from IndexedDB first before other methods
  try {
    const db = await openIndexedDB();
    if (db) {
      const games = await getAllGamesFromDB(db);
      if (games && games.length > 0) {
        return games;
      }
    }
  } catch (e) {
    console.warn('Error loading games from IndexedDB:', e);
  }

  // Try each category cache
  const categories = ['cloud', 'browser', 'emulator'];
  let allGames = [];

  for (const category of categories) {
    if (window.cache && window.cache[category] && Array.isArray(window.cache[category])) {
      allGames = [...allGames, ...window.cache[category]];
    } else {
      // Try localStorage
      try {
        const cachedData = localStorage.getItem(`cache_games_${category}`);
        if (cachedData) {
          const parsed = JSON.parse(cachedData);
          if (parsed.data && Array.isArray(parsed.data)) {
            allGames = [...allGames, ...parsed.data];
          }
        }
      } catch (e) {
        console.warn(`Error loading ${category} games from localStorage:`, e);
      }
    }
  }

  // If we have games, return them
  if (allGames.length > 0) {
    return allGames;
  }

  // Try to get from legacy cache
  try {
    const cachedData = localStorage.getItem('cache_games');
    if (cachedData) {
      const parsed = JSON.parse(cachedData);
      if (parsed.data && Array.isArray(parsed.data)) {
        return parsed.data;
      }
    }
  } catch (e) {
    console.warn('Error loading games from legacy cache:', e);
  }

  // Last resort: fetch from server and store in IndexedDB
  try {
    const response = await fetch('/json/g.json');
    if (!response.ok) throw new Error('Failed to fetch games data');

    const data = await response.json();

    // Store in IndexedDB for future use
    try {
      const db = await openIndexedDB();
      if (db) {
        await storeGamesInDB(db, data);
        console.log('Successfully stored games in IndexedDB');
      }
    } catch (e) {
      console.warn('Error storing games in IndexedDB:', e);
    }

    return data;
  } catch (error) {
    console.error('Error fetching games data:', error);
    return [];
  }
}
function updateGameDetails(game, allGames) {
  if (!game) return;

  const gameContainer = document.getElementById('game-container');
  const gameInfoSection = gameContainer.querySelector('.game-info');

  if (!gameInfoSection) return;

  // Clear any loading state
  gameInfoSection.innerHTML = '';

  // Create parallax background
  const parallaxContainer = document.createElement('div');
  parallaxContainer.className = 'game-parallax-container';

  const parallaxBackground = document.createElement('div');
  parallaxBackground.className = 'game-parallax-background';
  parallaxBackground.style.backgroundImage = `url('${game.img || '/assets/game-placeholder.jpg'}')`;

  const imageContainer = document.createElement('div');
  imageContainer.className = 'game-image-container';
  imageContainer.innerHTML = `<img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" class="game-detail-image">`;

  parallaxContainer.appendChild(parallaxBackground);
  parallaxContainer.appendChild(imageContainer);
  gameInfoSection.appendChild(parallaxContainer);

  // Game title
  const title = document.createElement('h1');
  title.textContent = game.name;
  gameInfoSection.appendChild(title);

  // Game tags
  if (game.tags && Array.isArray(game.tags) && game.tags.length > 0) {
    const tagsDiv = document.createElement('div');
    tagsDiv.className = 'game-tags';
    tagsDiv.innerHTML = game.tags.map(tag => `<span class="game-tag">${tag}</span>`).join('');
    gameInfoSection.appendChild(tagsDiv);
  }

  // Game metadata
  const metadataDiv = document.createElement('div');
  metadataDiv.className = 'game-metadata';

  // Category metadata
  metadataDiv.innerHTML += `
    <div class="metadata-item">
      <div class="metadata-icon">
        <i class="fa-solid fa-gamepad"></i>
      </div>
      <div>
        <span class="metadata-label">Category</span>
        <div class="metadata-value">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser'} Game</div>
      </div>
    </div>
  `;

  // Genre metadata (if available)
  if (game.genre) {
    metadataDiv.innerHTML += `
      <div class="metadata-item">
        <div class="metadata-icon">
          <i class="fa-solid fa-tag"></i>
        </div>
        <div>
          <span class="metadata-label">Genre</span>
          <div class="metadata-value">${game.genre}</div>
        </div>
      </div>
    `;
  }

  // Publisher metadata (if available)
  if (game.publisher) {
    metadataDiv.innerHTML += `
      <div class="metadata-item">
        <div class="metadata-icon">
          <i class="fa-solid fa-building"></i>
        </div>
        <div>
          <span class="metadata-label">Publisher</span>
          <div class="metadata-value">${game.publisher}</div>
        </div>
      </div>
    `;
  }

  // Release date metadata (if available)
  if (game.releaseDate) {
    metadataDiv.innerHTML += `
      <div class="metadata-item">
        <div class="metadata-icon">
          <i class="fa-solid fa-calendar-days"></i>
        </div>
        <div>
          <span class="metadata-label">Release Date</span>
          <div class="metadata-value">${game.releaseDate}</div>
        </div>
      </div>
    `;
  }

  gameInfoSection.appendChild(metadataDiv);

  // Game description
  const descriptionDiv = document.createElement('div');
  descriptionDiv.className = 'game-description';
  descriptionDiv.innerHTML = `
    <h3>About ${game.name}</h3>
    <p>${game.description || `${game.name} is a ${game.category || 'browser'} game available to play unblocked at school.`}</p>
    <p>Choose between directly opening the game in a new tab or using our secure Flamepass Proxy which
        can help bypass additional restrictions. The proxy option requires a free Flamepass account and
        adds an extra layer of protection.</p>
    <p>For the best experience, we recommend using the Flamepass Proxy option which helps evade content
        filtering systems and keeps your gaming activities private.</p>
  `;
  gameInfoSection.appendChild(descriptionDiv);

  // Game buttons
  const buttonsDiv = document.createElement('div');
  buttonsDiv.className = 'game-buttons';
  buttonsDiv.innerHTML = `
    <a href="${game.url || '#'}" class="play-button" id="openGameBtn" data-game-url="${game.url || '#'}">
      <i class="fa-solid fa-play"></i>
      Play Now
    </a>
    <a href="#" class="proxy-button" id="proxyGameBtn" data-game-url="${game.url || '#'}">
      <i class="fa-solid fa-shield-halved"></i>
      Play with Flamepass Proxy
    </a>
  `;
  gameInfoSection.appendChild(buttonsDiv);
}
function setupButtonHandlers(game) {
  if (!game) return;

  // Direct play button
  const openGameBtn = document.getElementById('openGameBtn');
  if (openGameBtn) {
    openGameBtn.addEventListener('click', (e) => {
      // Track play action for analytics
      if (window.gtag) {
        gtag('event', 'play_game', {
          'game_name': game.name,
          'game_category': game.category,
          'method': 'direct'
        });
      }
    });
  }

  // Proxy play button
  const proxyGameBtn = document.getElementById('proxyGameBtn');
  if (proxyGameBtn) {
    proxyGameBtn.addEventListener('click', (e) => {
      e.preventDefault();

      // Get game URL from data attribute
      const gameUrl = proxyGameBtn.getAttribute('data-game-url');

      // Check if user is logged in (would be implemented in auth-controller.min.js)
      const isLoggedIn = window.isUserLoggedIn ? window.isUserLoggedIn() : false;

      if (isLoggedIn) {
        // User is logged in, redirect to proxy
        window.open(`/&.html?url=${encodeURIComponent(gameUrl)}`, '_blank');

        // Track play action for analytics
        if (window.gtag) {
          gtag('event', 'play_game', {
            'game_name': game.name,
            'game_category': game.category,
            'method': 'proxy'
          });
        }
      } else {
        // User is not logged in, show auth modal
        const authModal = document.getElementById('authModal');
        if (authModal) {
          authModal.classList.add('active');

          // Track auth prompt
          if (window.gtag) {
            gtag('event', 'auth_prompt', {
              'trigger': 'proxy_play',
              'game_name': game.name
            });
          }
        }
      }
    });
  }
}

function setupCloudProviders(game) {
  if (!game || !game.serviceProviders) return;

  const providersContainer = document.getElementById('cloud-providers-container');
  const providersGrid = document.getElementById('providers-grid');

  if (!providersContainer || !providersGrid) return;

  // Clear existing providers
  providersGrid.innerHTML = '';

  // Loop through each service provider
  Object.entries(game.serviceProviders).forEach(([provider, info]) => {
    const providerCard = document.createElement('div');
    providerCard.className = 'provider-card';

    // Build provider card according to paste.txt template
    providerCard.innerHTML = `
      <div class="provider-logo">
        <img src="/assets/logo.webp" alt="${provider}" onerror="this.src='/assets/logo.webp'">
      </div>
      <h3 class="provider-name">${provider}</h3>
      <div class="provider-buttons">
        <a href="${info.url}" target="_blank" class="provider-direct-button">
          <i class="fa-solid fa-external-link-alt"></i>
          Direct
        </a>
        <a href="#" class="provider-proxy-button" data-provider-url="${info.url}">
          <i class="fa-solid fa-shield-alt"></i>
          Proxy
        </a>
      </div>
    `;

    providersGrid.appendChild(providerCard);
  });

  // Show the providers section
  providersContainer.style.display = game.category === 'cloud' ? 'block' : 'none';

  // Add event listeners to proxy buttons
  const proxyButtons = providersContainer.querySelectorAll('.provider-proxy-button');
  proxyButtons.forEach(button => {
    button.addEventListener('click', (e) => {
      e.preventDefault();

      // Get provider URL from data attribute
      const providerUrl = button.getAttribute('data-provider-url');

      // Check if user is logged in
      const isLoggedIn = window.isUserLoggedIn ? window.isUserLoggedIn() : false;

      if (isLoggedIn) {
        // User is logged in, redirect to proxy
        window.open(`/&.html?url=${encodeURIComponent(providerUrl)}`, '_blank');
      } else {
        // User is not logged in, show auth modal
        const authModal = document.getElementById('authModal');
        if (authModal) {
          authModal.classList.add('active');
        }
      }
    });
  });
}
async function initGamePage(slug) {
  if (!slug) return;

  try {
    // Show loading state
    showLoading();

    // Get game data
    const allGames = await fetchGames();
    const currentGame = allGames.find(game => game.slug === slug);

    // Store game data globally for other scripts
    window.currentGame = currentGame;
    window.allGames = allGames;

    if (!currentGame) {
      showError('Game Not Found', 'Sorry, we couldn\'t find the game you\'re looking for.');
      return;
    }

    // Update document title
    document.title = `Play ${currentGame.name} Unblocked on Flamepass`;

    // Update meta tags for SEO
    updateMetaTags(currentGame);

    // Update game details in the existing container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      updateGameDetails(currentGame, allGames);
    }

    // Setup button event handlers
    setupButtonHandlers(currentGame);

    // Setup cloud provider buttons if applicable
    if (currentGame.category === 'cloud' && currentGame.serviceProviders) {
      setupCloudProviders(currentGame);
    }

    // Initialize parallax effect
    initParallaxEffect();

    // Initialize components with all categories
    const categories = ['browser', 'emulator', 'cloud'];
    const currentCategory = currentGame.category || 'browser';

    // First show games from the same category
    updateCategoryBasedGames(currentGame, allGames, currentCategory);

    // Then show trending games
    updateTrendingGames(allGames);

    // Then show games from other categories
    categories.forEach(category => {
      if (category !== currentCategory) {
        updateCategoryGames(currentGame, allGames, category);
      }
    });

  } catch (error) {
    console.error('Error initializing game page:', error);
    showError('Error Loading Game', 'There was a problem loading the game details. Please try again later.');
  }
}

function updateMetaTags(game) {
  // Update meta description
  const metaDescription = document.querySelector('meta[name="description"]');
  if (metaDescription) {
    metaDescription.setAttribute('content',
      `Play ${game.name} unblocked at school with Flamepass, the next gen school proxy. No downloads required, bypasses school filters, works directly in your browser.`
    );
  }

  // Update meta keywords
  const metaKeywords = document.querySelector('meta[name="keywords"]');
  if (metaKeywords) {
    metaKeywords.setAttribute('content',
      `Unblocked Games, School Games, ${game.name} Unblocked, Bypass School Filters, Flamepass`
    );
  }

  // Update og:title
  const ogTitle = document.querySelector('meta[property="og:title"]');
  if (ogTitle) {
    ogTitle.setAttribute('content', `Play ${game.name} Unblocked | Flamepass`);
  }

  // Update canonical URL
  const canonical = document.querySelector('link[rel="canonical"]');
  if (canonical) {
    canonical.setAttribute('href', `/game/${game.slug}`);
  }
}
function initParallaxEffect() {
  const parallaxBackground = document.querySelector('.game-parallax-background');
  if (!parallaxBackground) return;

  // Add scroll event listener for parallax effect
  window.addEventListener('scroll', () => {
    const scrollPosition = window.scrollY;
    const translateY = Math.min(scrollPosition * 0.2, 100); // Limit max translation

    // Apply parallax effect
    parallaxBackground.style.transform = `translateY(${translateY}px)`;
    parallaxBackground.style.opacity = Math.max(1 - (scrollPosition * 0.002), 0.3); // Fade out slightly on scroll
  });
}

function initializeParticles() {
  if (window.particlesJS && document.getElementById('particles-js')) {
    particlesJS('particles-js', {
      particles: {
        number: { value: 80, density: { enable: true, value_area: 800 } },
        color: { value: '#ffffff' },
        shape: { type: 'circle' },
        opacity: { value: 0.5, random: true },
        size: { value: 3, random: true },
        line_linked: { enable: false },
        move: {
          enable: true,
          speed: 0.3,
          direction: 'top',
          random: true,
          straight: false,
          out_mode: 'out'
        }
      }
    });
  }
}

function showLoading() {
  const gameInfoSection = document.querySelector('.game-info');
  if (!gameInfoSection) return;

  gameInfoSection.innerHTML = `
    <div class="loading-container">
      <div class="game-loader">
        <svg viewBox="0 0 80 80">
          <circle cx="40" cy="40" r="32" class="loader-circle"></circle>
        </svg>
      </div>
      <h2 class="loading-text">Loading Game Details</h2>
      <p class="loading-subtext">Preparing your unblocked gaming experience...</p>
    </div>
  `;
}

function showError(title, message) {
  const gameContainer = document.getElementById('game-container');
  if (!gameContainer) return;

  // Update the first element with error message
  const firstElement = gameContainer.firstElementChild;
  if (firstElement) {
    firstElement.innerHTML = `
      <div class="error-message">
        <span class="material-symbols-outlined">error</span>
        <h3>${title}</h3>
        <p>${message}</p>
        <a href="/g.html" class="retry-button">
          <i class="fa-solid fa-gamepad"></i>
          Browse All Games
        </a>
      </div>
    `;
  }
}
function initializeDynamicComponents(currentGame) {
  // Initialize parallax effect
  initParallaxEffect();

  // Add event listeners to buttons
  setupButtonHandlers(currentGame);

  // Setup cloud provider buttons if applicable
  if (currentGame.category === 'cloud' && currentGame.serviceProviders) {
    setupCloudProviders(currentGame);
  }

  // Fetch all games for related content
  fetchGames().then(allGames => {
    // Store games data for other scripts
    window.allGames = allGames;

    // Update related games sections based on categories
    const categories = ['browser', 'emulator', 'cloud'];
    const currentCategory = currentGame.category || 'browser';

    // First show games from the same category
    updateCategoryBasedGames(currentGame, allGames, currentCategory);

    // Then show trending games
    updateTrendingGames(allGames);

    // Then show games from other categories
    categories.forEach(category => {
      if (category !== currentCategory) {
        updateCategoryGames(currentGame, allGames, category);
      }
    });

  }).catch(error => {
    console.error('Error fetching games for dynamic components:', error);
  });
}
function getRandomGames(games, count) {
  if (!Array.isArray(games) || games.length === 0) {
    return [];
  }

  // Shuffle array
  const shuffled = [...games].sort(() => 0.5 - Math.random());

  // Return up to count games
  return shuffled.slice(0, Math.min(count, shuffled.length));
}

function updateGameGrid(grid, games) {
  if (!grid || !Array.isArray(games)) return;

  // Clear grid first
  grid.innerHTML = '';

  // Add game cards to grid
  games.forEach(game => {
    const gameCard = document.createElement('a');
    gameCard.href = `/game/${game.slug}`;
    gameCard.className = 'game-card';

    gameCard.innerHTML = `
      <div class="game-card-image">
        <img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" loading="lazy">
      </div>
      <div class="game-card-info">
        <h3>${game.name}</h3>
        <div class="game-card-meta">
          <span class="category-pill">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser'}</span>
        </div>
      </div>
    `;

    grid.appendChild(gameCard);
  });
}

function updateCategoryBasedGames(game, allGames, category) {
  if (!game || !allGames || !category) return;

  // Create container if not exists
  let container = document.querySelector('.category-games-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'category-games-container';

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // Filter games from the same category, but not the current game
  const categoryGames = allGames.filter(g =>
    g.category === category && g.slug !== game.slug
  );

  // If no games, hide container
  if (categoryGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games from category (up to 4)
  const gamesToShow = getRandomGames(categoryGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';
  header.innerHTML = `
    <h2>More ${category.charAt(0).toUpperCase() + category.slice(1)} Games</h2>
    <a href="/g.html?category=${category}" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}
function updateTrendingGames(allGames) {
  if (!allGames) return;

  // Create container if not exists
  let container = document.querySelector('.trending-games-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'trending-games-container';

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // If no games, hide container
  if (allGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games (up to 4) - in a real app, this would be most popular
  const gamesToShow = getRandomGames(allGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';
  header.innerHTML = `
    <h2>Trending Games</h2>
    <a href="/g.html?trending=true" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}

function updateCategoryGames(game, allGames, category) {
  if (!game || !allGames || !category) return;

  // Create container if not exists
  let container = document.querySelector(`.${category}-games-container`);
  if (!container) {
    container = document.createElement('div');
    container.className = `${category}-games-container`;

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // Filter games from the specific category, but not the current game
  const categoryGames = allGames.filter(g =>
    g.category === category && g.slug !== game.slug
  );

  // If no games, hide container
  if (categoryGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games from category (up to 4)
  const gamesToShow = getRandomGames(categoryGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';

  // Customize title based on category
  let title;
  switch (category) {
    case 'browser':
      title = 'HTML5 Browser Games';
      break;
    case 'emulator':
      title = 'Emulator Games';
      break;
    case 'cloud':
      title = 'Cloud Gaming';
      break;
    default:
      title = `${category.charAt(0).toUpperCase() + category.slice(1)} Games`;
  }

  header.innerHTML = `
    <h2>${title}</h2>
    <a href="/g.html?category=${category}" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}
function initSearch() {
  const searchTrigger = document.getElementById('searchTrigger');
  const searchModal = document.getElementById('searchModal');
  const closeSearch = document.getElementById('closeSearch');
  const searchInput = document.getElementById('searchInput');
  const searchResults = document.getElementById('searchResults');

  if (!searchTrigger || !searchModal || !closeSearch || !searchInput || !searchResults) {
    console.warn('Search elements not found. Search functionality disabled.');
    return;
  }

  // Open search modal
  searchTrigger.addEventListener('click', () => {
    openSearchModal();
  });

  // Close search modal
  closeSearch.addEventListener('click', () => {
    closeSearchModal();
  });

  // Click outside to close
  searchModal.addEventListener('click', (e) => {
    if (e.target === searchModal) {
      closeSearchModal();
    }
  });

  // Search input handler with debounce
  let debounceTimer;
  searchInput.addEventListener('input', () => {
    clearTimeout(debounceTimer);

    const query = searchInput.value.trim();

    if (query.length < 2) {
      searchResults.innerHTML = `
        <div class="search-message">
          <span class="material-symbols-outlined">search</span>
          <p>Type at least 2 characters to search</p>
        </div>
      `;
      return;
    }

    // Set loading state
    searchResults.innerHTML = `
      <div class="search-message">
        <div class="loader" style="width: 30px; height: 30px;">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="32" class="loader-circle" />
          </svg>
        </div>
        <p>Searching...</p>
      </div>
    `;

    // Debounce search request
    debounceTimer = setTimeout(() => {
      performSearch(query.toLowerCase());
    }, 300);
  });
}

function openSearchModal() {
  const searchModal = document.getElementById('searchModal');
  const searchInput = document.getElementById('searchInput');

  if (!searchModal || !searchInput) return;

  searchModal.classList.add('active');

  // Focus input after animation
  setTimeout(() => {
    searchInput.focus();
  }, 100);

  // Disable body scroll
  document.body.style.overflow = 'hidden';
}

function closeSearchModal() {
  const searchModal = document.getElementById('searchModal');
  const searchInput = document.getElementById('searchInput');

  if (!searchModal || !searchInput) return;

  searchModal.classList.remove('active');
  searchInput.value = '';

  // Enable body scroll
  document.body.style.overflow = '';
}
async function performSearch(query) {
  const searchResults = document.getElementById('searchResults');

  if (!searchResults) return;

  try {
    // Get all games
    const allGames = await fetchGames();

    console.log(`Searching through ${allGames.length} games for "${query}"`);

    // Filter games based on query
    const filteredGames = allGames.filter(game =>
      (game.name && game.name.toLowerCase().includes(query)) ||
      (game.description && game.description.toLowerCase().includes(query)) ||
      (game.category && game.category.toLowerCase().includes(query)) ||
      (game.publisher && game.publisher.toLowerCase().includes(query)) ||
      (game.tags && Array.isArray(game.tags) && game.tags.some(tag => tag.toLowerCase().includes(query)))
    );

    // Display results
    if (filteredGames.length === 0) {
      searchResults.innerHTML = `
        <div class="search-message">
          <span class="material-symbols-outlined">sentiment_dissatisfied</span>
          <p>No games found matching "${query}"</p>
        </div>
      `;
    } else {
      searchResults.innerHTML = '';

      filteredGames.slice(0, 8).forEach(game => {
        const resultItem = document.createElement('a');
        resultItem.href = `/game/${game.slug}`;
        resultItem.className = 'search-result-item';

        resultItem.innerHTML = `
          <div class="search-result-image">
            <img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" loading="lazy">
          </div>
          <div class="search-result-info">
            <h3>${game.name}</h3>
            <div class="search-result-meta">
              <span class="category-pill">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser Game'}</span>
              ${game.publisher ? `<span class="publisher">${game.publisher}</span>` : ''}
            </div>
          </div>
        `;

        searchResults.appendChild(resultItem);
      });

      if (filteredGames.length > 8) {
        const viewAll = document.createElement('a');
        viewAll.href = `/g.html?search=${encodeURIComponent(query)}`;
        viewAll.className = 'view-all-results';
        viewAll.innerHTML = `View all ${filteredGames.length} results <span class="material-symbols-outlined">arrow_forward</span>`;
        searchResults.appendChild(viewAll);
      }
    }
  } catch (error) {
    console.error('Error during search:', error);
    searchResults.innerHTML = `
      <div class="search-message">
        <span class="material-symbols-outlined">error</span>
        <p>An error occurred while searching</p>
      </div>
    `;
  }
}
function initScrollToTop() {
  const scrollTopBtn = document.getElementById('scrollTopBtn');

  if (!scrollTopBtn) return;

  // Show/hide button based on scroll position
  window.addEventListener('scroll', () => {
    if (document.documentElement.scrollTop > 300) {
      scrollTopBtn.classList.add('visible');
    } else {
      scrollTopBtn.classList.remove('visible');
    }
  });

  // Scroll to top when clicked
  scrollTopBtn.addEventListener('click', () => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  });
}

function setupKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    // Open search with Cmd+K or Ctrl+K
    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
      e.preventDefault();
      openSearchModal();
    }

    // Close search with Escape
    if (e.key === 'Escape') {
      closeSearchModal();

      // Also close auth modal if open
      const authModal = document.getElementById('authModal');
      if (authModal && authModal.classList.contains('active')) {
        authModal.classList.remove('active');
      }
    }
  });
}

