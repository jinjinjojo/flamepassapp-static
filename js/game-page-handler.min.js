/**
 * UI UTILITY FUNCTIONS
 */

// Function to initialize the scroll to top button
function initScrollToTop() {
  const scrollTopBtn = document.getElementById('scrollTopBtn');

  if (!scrollTopBtn) return;

  // Show/hide button based on scroll position
  window.addEventListener('scroll', () => {
    if (document.documentElement.scrollTop > 300) {
      scrollTopBtn.classList.add('visible');
    } else {
      scrollTopBtn.classList.remove('visible');
    }
  });

  // Scroll to top when clicked
  scrollTopBtn.addEventListener('click', () => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  });
}

// Function to setup keyboard shortcuts
function setupKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    // Open search with Cmd+K or Ctrl+K
    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
      e.preventDefault();
      openSearchModal();
    }

    // Close search with Escape
    if (e.key === 'Escape') {
      closeSearchModal();

      // Also close auth modal if open
      const authModal = document.getElementById('authModal');
      if (authModal && authModal.classList.contains('active')) {
        authModal.classList.remove('active');
      }
    }
  });
}

/**
 * DATA FETCHING AND UTILITIES
 */

// Function to fetch games data from various sources
async function fetchGames() {
  // Try to get from window cache first (may be set by other scripts)
  if (window.allGames && Array.isArray(window.allGames) && window.allGames.length > 0) {
    return window.allGames;
  }

  // Try to get from memory cache
  if (window.cache && window.cache.games && Array.isArray(window.cache.games)) {
    return window.cache.games;
  }

  // Try each category cache
  const categories = ['cloud', 'browser', 'emulator'];
  let allGames = [];

  for (const category of categories) {
    if (window.cache && window.cache[category] && Array.isArray(window.cache[category])) {
      allGames = [...allGames, ...window.cache[category]];
    } else {
      // Try localStorage
      try {
        const cachedData = localStorage.getItem(`cache_games_${category}`);
        if (cachedData) {
          const parsed = JSON.parse(cachedData);
          if (parsed.data && Array.isArray(parsed.data)) {
            allGames = [...allGames, ...parsed.data];
          }
        }
      } catch (e) {
        console.warn(`Error loading ${category} games from localStorage:`, e);
      }
    }
  }

  // If we have games, return them
  if (allGames.length > 0) {
    return allGames;
  }

  // Try to get from IndexedDB
  try {
    const db = await openIndexedDB();
    if (db) {
      const games = await getAllGamesFromDB(db);
      if (games && games.length > 0) {
        return games;
      }
    }
  } catch (e) {
    console.warn('Error loading games from IndexedDB:', e);
  }

  // Last resort: try to get from legacy cache
  try {
    const cachedData = localStorage.getItem('cache_games');
    if (cachedData) {
      const parsed = JSON.parse(cachedData);
      if (parsed.data && Array.isArray(parsed.data)) {
        return parsed.data;
      }
    }
  } catch (e) {
    console.warn('Error loading games from legacy cache:', e);
  }

  // If all else fails, fetch from server
  try {
    const response = await fetch('/json/g.json');
    if (!response.ok) throw new Error('Failed to fetch games data');

    const data = await response.json();

    // Add some sample data for publisher and releaseDate for cloud games
    // (This would come from the server in a real implementation)
    const enhancedData = data.map(game => {
      if (game.category === 'cloud' && !game.publisher) {
        // Add publisher and release date for cloud games
        const publishers = [
          'Epic Games', 'Activision', 'EA Games', 'Ubisoft',
          'Rockstar Games', 'Valve', 'Bethesda', 'Square Enix',
          'Nintendo', 'Sony Interactive', 'Blizzard', 'Sega'
        ];

        const dates = [
          'Jan 2023', 'Mar 2023', 'Sep 2022', 'Dec 2022',
          'May 2022', 'Oct 2021', 'Feb 2022', 'Apr 2023',
          'Nov 2022', 'Aug 2022', 'Jun 2023', 'Jul 2022'
        ];

        // Generate a deterministic but seemingly random publisher and date
        const index = game.name.length % publishers.length;
        return {
          ...game,
          publisher: publishers[index],
          releaseDate: dates[index]
        };
      }
      return game;
    });

    return enhancedData;
  } catch (error) {
    console.error('Error fetching games data:', error);
    return [];
  }
}

// Helper function to open IndexedDB
function openIndexedDB() {
  return new Promise((resolve, reject) => {
    if (!window.indexedDB) {
      resolve(null);
      return;
    }

    const request = indexedDB.open('flamepass_games', 1);

    request.onerror = event => {
      console.error('IndexedDB error:', event.target.error);
      resolve(null);
    };

    request.onsuccess = event => {
      resolve(event.target.result);
    };

    request.onupgradeneeded = event => {
      const db = event.target.result;

      if (!db.objectStoreNames.contains('games')) {
        db.createObjectStore('games', { keyPath: 'slug' });
      }

      if (!db.objectStoreNames.contains('meta')) {
        db.createObjectStore('meta', { keyPath: 'key' });
      }
    };
  });
}

// Helper function to get all games from IndexedDB
function getAllGamesFromDB(db) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['games'], 'readonly');
    const store = transaction.objectStore('games');
    const request = store.getAll();

    request.onsuccess = event => {
      resolve(event.target.result);
    };

    request.onerror = event => {
      console.error('Error getting games from IndexedDB:', event.target.error);
      resolve([]);
    };
  });
}

// Helper function to get random games
function getRandomGames(games, count) {
  if (!Array.isArray(games) || games.length === 0) {
    return [];
  }

  // Shuffle array
  const shuffled = [...games].sort(() => 0.5 - Math.random());

  // Return up to count games
  return shuffled.slice(0, Math.min(count, shuffled.length));
}

/**
 * ERROR HANDLING AND RECOVERY
 */

// Error handling and recovery
window.addEventListener('error', (event) => {
  console.error('Global error caught:', event.error);

  // Check if it's related to game loading
  if (event.error && event.error.message && (
    event.error.message.includes('game') ||
    event.error.message.includes('render')
  )) {
    const container = document.getElementById('game-container');
    if (container && container.querySelector('.loading-container')) {
      // Show error message if still loading
      container.innerHTML = `
        <div class="error-message">
          <span class="material-symbols-outlined" style="font-size: 3rem; color: var(--accent-primary); margin-bottom: 15px;">error</span>
          <h1>Something went wrong</h1>
          <p>We encountered an error while loading the game information.</p>
          <button class="retry-button" onclick="window.location.reload()">
            <i class="fa-solid fa-refresh"></i> Try Again
          </button>
        </div>
      `;
    }
  }
});

// Check for game loading errors and fix them after a timeout
setTimeout(() => {
  // Only run this on the game page
  if (!window.location.pathname.startsWith('/game/')) return;

  const loadingContainer = document.querySelector('.loading-container');
  const gameContainer = document.getElementById('game-container');

  if (loadingContainer && gameContainer) {
    // Game hasn't loaded yet, attempt to fix
    console.warn('Game loading timeout detected, attempting to recover');

    // Extract game slug from URL
    const slug = window.location.pathname.split('/').pop();

    // Try to load game details manually
    fetchGames().then(games => {
      const game = games.find(g => g.slug === slug);

      if (game) {
        // Update game details manually
        updateGameDetails(game, games);

        // Update related and trending content using all categories
        const categories = ['browser', 'emulator', 'cloud'];
        const currentCategory = game.category || 'browser';

        // First show games from the same category
        updateCategoryBasedGames(game, games, currentCategory);

        // Then show trending games
        updateTrendingGames(games);

        // Then show games from other categories
        categories.forEach(category => {
          if (category !== currentCategory) {
            updateCategoryGames(game, games, category);
          }
        });
      } else {
        // Show error message
        showError('Game Not Found', 'Sorry, we couldn\'t find the game you\'re looking for.');
      }
    }).catch(error => {
      console.error('Error in manual game loading:', error);
      showError('Error Loading Game', 'There was a problem loading the game details. Please try again later.');
    });
  }
}, 3000);

// Initialize particles if available
function initializeParticles() {
  if (window.particlesJS && document.getElementById('particles-js')) {
    particlesJS('particles-js', {
      particles: {
        number: { value: 80, density: { enable: true, value_area: 800 } },
        color: { value: '#ff6600' },
        shape: { type: 'circle' },
        opacity: { value: 0.3, random: true },
        size: { value: 3, random: true },
        line_linked: { enable: false },
        move: {
          enable: true,
          speed: 0.3,
          direction: 'top',
          random: true,
          straight: false,
          out_mode: 'out'
        }
      }
    });
  }
}/**
 * SEARCH FUNCTIONALITY
 */

// Function to initialize search functionality
function initSearch() {
  const searchTrigger = document.getElementById('searchTrigger');
  const searchModal = document.getElementById('searchModal');
  const closeSearch = document.getElementById('closeSearch');
  const searchInput = document.getElementById('searchInput');
  const searchResults = document.getElementById('searchResults');

  if (!searchTrigger || !searchModal || !closeSearch || !searchInput || !searchResults) {
    console.warn('Search elements not found. Search functionality disabled.');
    return;
  }

  // Open search modal
  searchTrigger.addEventListener('click', () => {
    openSearchModal();
  });

  // Close search modal
  closeSearch.addEventListener('click', () => {
    closeSearchModal();
  });

  // Click outside to close
  searchModal.addEventListener('click', (e) => {
    if (e.target === searchModal) {
      closeSearchModal();
    }
  });

  // Search input handler with debounce
  let debounceTimer;
  searchInput.addEventListener('input', () => {
    clearTimeout(debounceTimer);

    const query = searchInput.value.trim();

    if (query.length < 2) {
      searchResults.innerHTML = `
        <div class="search-message">
          <span class="material-symbols-outlined">search</span>
          <p>Type at least 2 characters to search</p>
        </div>
      `;
      return;
    }

    // Set loading state
    searchResults.innerHTML = `
      <div class="search-message">
        <div class="loader" style="width: 30px; height: 30px;">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="32" class="loader-circle" />
          </svg>
        </div>
        <p>Searching...</p>
      </div>
    `;

    // Debounce search request
    debounceTimer = setTimeout(() => {
      performSearch(query.toLowerCase());
    }, 300);
  });
}

// Function to open search modal
function openSearchModal() {
  const searchModal = document.getElementById('searchModal');
  const searchInput = document.getElementById('searchInput');

  if (!searchModal || !searchInput) return;

  searchModal.classList.add('active');

  // Focus input after animation
  setTimeout(() => {
    searchInput.focus();
  }, 100);

  // Disable body scroll
  document.body.style.overflow = 'hidden';
}

// Function to close search modal
function closeSearchModal() {
  const searchModal = document.getElementById('searchModal');
  const searchInput = document.getElementById('searchInput');

  if (!searchModal || !searchInput) return;

  searchModal.classList.remove('active');
  searchInput.value = '';

  // Enable body scroll
  document.body.style.overflow = '';
}

// Function to perform search
async function performSearch(query) {
  const searchResults = document.getElementById('searchResults');

  if (!searchResults) return;

  try {
    // Get all games
    const allGames = await fetchGames();

    console.log(`Searching through ${allGames.length} games for "${query}"`);

    // Filter games based on query
    const filteredGames = allGames.filter(game =>
      (game.name && game.name.toLowerCase().includes(query)) ||
      (game.description && game.description.toLowerCase().includes(query)) ||
      (game.category && game.category.toLowerCase().includes(query)) ||
      (game.publisher && game.publisher.toLowerCase().includes(query)) ||
      (game.tags && Array.isArray(game.tags) && game.tags.some(tag => tag.toLowerCase().includes(query)))
    );

    // Display results
    if (filteredGames.length === 0) {
      searchResults.innerHTML = `
        <div class="search-message">
          <span class="material-symbols-outlined">sentiment_dissatisfied</span>
          <p>No games found matching "${query}"</p>
        </div>
      `;
    } else {
      searchResults.innerHTML = '';

      filteredGames.slice(0, 8).forEach(game => {
        const resultItem = document.createElement('a');
        resultItem.href = `/game/${game.slug}`;
        resultItem.className = 'search-result-item';

        resultItem.innerHTML = `
          <div class="search-result-image">
            <img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" loading="lazy">
          </div>
          <div class="search-result-info">
            <h3>${game.name}</h3>
            <div class="search-result-meta">
              <span class="category-pill">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser Game'}</span>
              ${game.publisher ? `<span class="publisher">${game.publisher}</span>` : ''}
            </div>
          </div>
        `;

        searchResults.appendChild(resultItem);
      });

      if (filteredGames.length > 8) {
        const viewAll = document.createElement('a');
        viewAll.href = `/g.html?search=${encodeURIComponent(query)}`;
        viewAll.className = 'view-all-results';
        viewAll.innerHTML = `View all ${filteredGames.length} results <span class="material-symbols-outlined">arrow_forward</span>`;
        searchResults.appendChild(viewAll);
      }
    }
  } catch (error) {
    console.error('Error during search:', error);
    searchResults.innerHTML = `
      <div class="search-message">
        <span class="material-symbols-outlined">error</span>
        <p>An error occurred while searching</p>
      </div>
    `;
  }
}// Helper function to update game grid
function updateGameGrid(container, games) {
  if (!container || !games || !Array.isArray(games)) return;

  // Clear existing content
  container.innerHTML = '';

  // Update each game card
  games.forEach((game) => {
    const gameCard = document.createElement('a');
    gameCard.href = `/game/${game.slug}`;
    gameCard.className = 'game-card';

    // Create card HTML
    gameCard.innerHTML = `
      <div class="game-card-image">
        <img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" loading="lazy">
        <div class="game-card-overlay">
          <h3>${game.name}</h3>
        </div>
      </div>
      <div class="game-card-details">
        <span class="game-category">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser'}</span>
        ${game.publisher ? `<span class="game-publisher">${game.publisher}</span>` : ''}
      </div>
    `;

    container.appendChild(gameCard);
  });
}

// Update cloud service providers section
function updateCloudProviders(game) {
  // Only show for cloud games
  if (!game || game.category !== 'cloud') {
    const container = document.getElementById('cloud-providers-container');
    if (container) {
      container.style.display = 'none';
    }
    return;
  }

  const container = document.getElementById('cloud-providers-container');
  if (!container) {
    return;
  }

  // Show the container
  container.style.display = 'block';

  // Find the grid
  const providersGrid = container.querySelector('#providers-grid');
  if (!providersGrid) {
    return;
  }

  // Clear existing content
  providersGrid.innerHTML = '';

  // Generate content based on serviceProviders
  if (game.serviceProviders && Object.keys(game.serviceProviders).length > 0) {
    Object.entries(game.serviceProviders).forEach(([provider, info]) => {
      const providerCard = document.createElement('div');
      providerCard.className = 'provider-card';

      providerCard.innerHTML = `
        <div class="provider-logo">
          <img src="/assets/providers/${provider.toLowerCase()}.webp" alt="${provider}" onerror="this.src='/assets/logo.webp'">
        </div>
        <h3 class="provider-name">${provider}</h3>
        <div class="provider-buttons">
          <a href="${info.url}" target="_blank" class="provider-direct-button">
            <i class="fa-solid fa-external-link-alt"></i>
            Direct
          </a>
          <a href="#" class="provider-proxy-button" data-provider-url="${info.url}">
            <i class="fa-solid fa-shield-alt"></i>
            Proxy
          </a>
        </div>
      `;

      providersGrid.appendChild(providerCard);
    });

    // Setup event listeners for the proxy buttons
    const proxyButtons = providersGrid.querySelectorAll('.provider-proxy-button');
    proxyButtons.forEach(button => {
      button.addEventListener('click', (e) => {
        e.preventDefault();

        const providerUrl = button.getAttribute('data-provider-url');
        if (!providerUrl) {
          console.error('Provider URL not found');
          return;
        }

        // Use the same proxy mechanism as the main game button
        handleProxyGame(e, providerUrl);
      });
    });
  } else {
    // No providers available
    providersGrid.innerHTML = `
      <div class="no-providers">
        <p>No cloud gaming providers available for this game.</p>
      </div>
    `;
  }
}

// Function to update the unblocking tips section
function updateUnblockingTips(game) {
  // Check if the unblock-info-section exists
  const unblockSection = document.querySelector('.unblock-info-section');
  if (!unblockSection) return;

  // Update section title if needed to include game name
  const sectionTitle = unblockSection.querySelector('h2');
  if (sectionTitle) {
    sectionTitle.textContent = `How to Play ${game.name} Unblocked at School`;
  }

  // Make sure the unblock tips container exists
  const tipsContainer = unblockSection.querySelector('.unblock-tips');
  if (!tipsContainer) {
    // If the container doesn't exist, create it
    const newTipsContainer = document.createElement('div');
    newTipsContainer.className = 'unblock-tips';

    // Add the standard tips
    newTipsContainer.innerHTML = `
      <div class="tip-card">
        <div class="tip-icon">
          <i class="fa-solid fa-shield"></i>
        </div>
        <h3 class="tip-title">Use Flamepass Proxy</h3>
        <p class="tip-description">Our secure proxy can bypass most school filters and keeps your gaming activity hidden from monitoring systems.</p>
      </div>

      <div class="tip-card">
        <div class="tip-icon">
          <i class="fa-solid fa-clock"></i>
        </div>
        <h3 class="tip-title">Private Browsing</h3>
        <p class="tip-description">Use incognito or private browsing mode to prevent browsing history from being stored on school computers.</p>
      </div>

      <div class="tip-card">
        <div class="tip-icon">
          <i class="fa-solid fa-bolt"></i>
        </div>
        <h3 class="tip-title">Alternative Links</h3>
        <p class="tip-description">Check our Discord for alternative domain links if the main Flamepass site gets blocked at your school.</p>
      </div>
      
      <div class="tip-card">
        <div class="tip-icon">
          <i class="fa-solid fa-wifi"></i>
        </div>
        <h3 class="tip-title">VPN Alternatives</h3>
        <p class="tip-description">If proxy isn't working, try using a browser-based VPN extension or Flamepass's built-in tunneling system.</p>
      </div>
    `;

    // Add the container to the unblock section
    unblockSection.appendChild(newTipsContainer);
  }

  // Make sure the advanced-tips section exists
  if (!unblockSection.querySelector('.advanced-tips')) {
    const advancedTips = document.createElement('div');
    advancedTips.className = 'advanced-tips';
    advancedTips.innerHTML = `
      <h3>Advanced Unblocking Methods</h3>
      <div class="advanced-tips-grid">
        <div class="advanced-tip">
          <div class="advanced-tip-icon">
            <i class="fa-solid fa-user-secret"></i>
          </div>
          <div class="advanced-tip-content">
            <h4>User Agent Switching</h4>
            <p>Some school filters rely on browser identification. Try changing your user agent to appear as a different device.</p>
          </div>
        </div>
        
        <div class="advanced-tip">
          <div class="advanced-tip-icon">
            <i class="fa-solid fa-server"></i>
          </div>
          <div class="advanced-tip-content">
            <h4>DNS Changing</h4>
            <p>Change your DNS settings to bypass basic network restrictions (works best on personal devices).</p>
          </div>
        </div>
        
        <div class="advanced-tip">
          <div class="advanced-tip-icon">
            <i class="fa-solid fa-window-restore"></i>
          </div>
          <div class="advanced-tip-content">
            <h4>About:blank Cloaking</h4>
            <p>Launch games through an about:blank page to hide the actual URL from basic monitoring systems.</p>
          </div>
        </div>
        
        <div class="advanced-tip">
          <div class="advanced-tip-icon">
            <i class="fa-solid fa-key"></i>
          </div>
          <div class="advanced-tip-content">
            <h4>Browser Extension Cache</h4>
            <p>Install extensions that cache games locally, allowing you to play offline when restrictions tighten.</p>
          </div>
        </div>
      </div>
    `;
    unblockSection.appendChild(advancedTips);
  }

  // Add game-specific tips based on category
  if (game.category) {
    const gameSpecificTip = document.createElement('div');
    gameSpecificTip.className = 'game-specific-tip';

    let tipContent = '';

    switch (game.category.toLowerCase()) {
      case 'browser':
      case 'html5':
        tipContent = `
          <h3>Tips for ${game.name} (${game.category.toUpperCase()} Game)</h3>
          <p>This HTML5 game can be cached for offline play. Visit once with a stable connection to save game assets locally.</p>
          <div class="game-specific-buttons">
            <a href="#" class="game-tip-button" onclick="window.open('${game.url}', '_blank'); return false;">
              <i class="fa-solid fa-download"></i> Cache for Offline
            </a>
          </div>
        `;
        break;
      case 'emulator':
        tipContent = `
          <h3>Tips for ${game.name} (Emulator Game)</h3>
          <p>This emulator game requires more resources than standard HTML5 games. For the best experience:</p>
          <ul class="game-tips-list">
            <li>Use Chrome or Edge browser for best compatibility</li>
            <li>Allow the emulator to load completely before playing</li>
            <li>For saving progress, create a free Flamepass account</li>
          </ul>
        `;
        break;
      case 'cloud':
        tipContent = `
          <h3>Tips for ${game.name} (Cloud Game)</h3>
          <p>This is a cloud-streamed game that requires a stable internet connection. For the best experience:</p>
          <ul class="game-tips-list">
            <li>Use a wired connection or strong Wi-Fi</li>
            <li>Close other tabs to free up bandwidth</li>
            <li>Use the Flamepass Proxy for reduced latency</li>
          </ul>
        `;
        break;
    }

    if (tipContent) {
      gameSpecificTip.innerHTML = tipContent;

      // Check if it already exists
      const existingTip = unblockSection.querySelector('.game-specific-tip');
      if (existingTip) {
        existingTip.innerHTML = tipContent;
      } else {
        // Insert after the unblock-tips section
        const tipsSection = unblockSection.querySelector('.unblock-tips');
        if (tipsSection) {
          tipsSection.parentNode.insertBefore(gameSpecificTip, tipsSection.nextSibling);
        } else {
          unblockSection.appendChild(gameSpecificTip);
        }
      }
    }
  }
}/**
 * Enhanced Game Page Handler
 * Works with both server-side rendering and client-side rendering
 */

document.addEventListener('DOMContentLoaded', () => {
  // Check if we're on a game page
  if (window.location.pathname.startsWith('/game/')) {
    // Check if we have server-rendered game data
    if (window.currentGame && window.currentGame.slug) {
      console.log('Using server-rendered game data:', window.currentGame);
      // Initialize just the dynamic parts since the page is already server-rendered
      initializeDynamicComponents(window.currentGame);
    } else {
      // Fall back to client-side rendering
      const slug = window.location.pathname.split('/').pop();
      initGamePage(slug);
    }
  }

  // Initialize the search functionality
  initSearch();

  // Initialize the scroll to top button
  initScrollToTop();

  // Setup keyboard shortcuts
  setupKeyboardShortcuts();

  // Initialize particles.js if available
  initializeParticles();
});

/**
 * Initialize dynamic components for server-rendered pages
 */
function initializeDynamicComponents(currentGame) {
  // Initialize parallax effect
  initParallaxEffect();

  // Add event listeners to buttons
  setupButtonHandlers(currentGame);

  // Setup cloud provider buttons if applicable
  setupCloudProviderButtons();

  // Fetch all games for related content
  fetchGames().then(allGames => {
    // Store games data for other scripts
    window.allGames = allGames;

    // Update related games sections based on categories
    const categories = ['browser', 'emulator', 'cloud'];
    const currentCategory = currentGame.category || 'browser';

    // First show games from the same category
    updateCategoryBasedGames(currentGame, allGames, currentCategory);

    // Then show trending games
    updateTrendingGames(allGames);

    // Then show games from other categories
    categories.forEach(category => {
      if (category !== currentCategory) {
        updateCategoryGames(currentGame, allGames, category);
      }
    });

  }).catch(error => {
    console.error('Error fetching games for dynamic components:', error);
  });
}

/**
 * Setup button handlers for game actions
 */
function setupButtonHandlers(game) {
  const openButton = document.getElementById('openGameBtn');
  const proxyButton = document.getElementById('proxyGameBtn');

  if (openButton) {
    // Remove any existing click handlers
    const newOpenButton = openButton.cloneNode(true);
    openButton.parentNode.replaceChild(newOpenButton, openButton);
    newOpenButton.addEventListener('click', handleOpenGame);
  }

  if (proxyButton) {
    // Remove any existing click handlers
    const newProxyButton = proxyButton.cloneNode(true);
    proxyButton.parentNode.replaceChild(newProxyButton, proxyButton);
    newProxyButton.addEventListener('click', handleProxyGame);
  }
}

/**
 * Setup cloud provider buttons
 */
function setupCloudProviderButtons() {
  const providerProxyButtons = document.querySelectorAll('.provider-proxy-button');

  providerProxyButtons.forEach(button => {
    button.addEventListener('click', (e) => {
      e.preventDefault();

      const providerUrl = button.getAttribute('data-provider-url');
      if (!providerUrl) {
        console.error('Provider URL not found');
        return;
      }

      // Use the same proxy mechanism as the main game button
      handleProxyGame(e, providerUrl);
    });
  });
}

/**
 * GAME PAGE INITIALIZATION (fallback for client-side rendering)
 */

// Initialize the game page
async function initGamePage(slug) {
  if (!slug) return;

  try {
    // Show loading state
    showLoading();

    // Get game data
    const allGames = await fetchGames();
    const currentGame = allGames.find(game => game.slug === slug);

    // Store game data globally for other scripts
    window.currentGame = currentGame;
    window.allGames = allGames;

    if (!currentGame) {
      showError('Game Not Found', 'Sorry, we couldn\'t find the game you\'re looking for.');
      return;
    }

    // Update game details in the existing container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      updateGameDetails(currentGame, allGames);
    }

    // Initialize components with all categories
    const categories = ['browser', 'emulator', 'cloud'];
    const currentCategory = currentGame.category || 'browser';

    // First show games from the same category
    updateCategoryBasedGames(currentGame, allGames, currentCategory);

    // Then show trending games
    updateTrendingGames(allGames);

    // Then show games from other categories
    categories.forEach(category => {
      if (category !== currentCategory) {
        updateCategoryGames(currentGame, allGames, category);
      }
    });

  } catch (error) {
    console.error('Error initializing game page:', error);
    showError('Error Loading Game', 'There was a problem loading the game details. Please try again later.');
  }
}

// Show loading state
function showLoading() {
  const gameContainer = document.getElementById('game-container');
  if (!gameContainer) return;

  // Create a loading indicator inside the first element of game container
  const firstElement = gameContainer.firstElementChild;
  if (firstElement) {
    firstElement.innerHTML = `
      <div class="loading-container">
        <div class="loader">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="32" class="loader-circle"></circle>
          </svg>
        </div>
        <div class="loading-text">Loading game details...</div>
      </div>`
    // Add parallax effect
  initParallaxEffect();

  // Update buttons with game URL
  const openButton = document.getElementById('openGameBtn');
  const proxyButton = document.getElementById('proxyGameBtn');

  if (openButton && game.url) {
    openButton.setAttribute('data-game-url', game.url);

    // Remove any existing click handlers
    const newOpenButton = openButton.cloneNode(true);
    openButton.parentNode.replaceChild(newOpenButton, openButton);
    newOpenButton.addEventListener('click', handleOpenGame);
  }

  if (proxyButton && game.url) {
    proxyButton.setAttribute('data-game-url', game.url);

    // Remove any existing click handlers
    const newProxyButton = proxyButton.cloneNode(true);
    proxyButton.parentNode.replaceChild(newProxyButton, proxyButton);
    newProxyButton.addEventListener('click', handleProxyGame);
  }

  // Update unblocking tips section for this specific game
  updateUnblockingTips(game);

  // Update cloud service providers section if applicable
  updateCloudProviders(game);
}

// Helper function to generate game tags HTML
function generateGameTags(game) {
  if (!game.tags || !Array.isArray(game.tags) || game.tags.length === 0) {
    return '';
  }

  return game.tags.map(tag => `
      < span class="game-tag" > ${ tag }</ >
        `).join('');
}

// Initialize parallax effect for the game image
function initParallaxEffect() {
  const parallaxBg = document.querySelector('.game-parallax-background');
  if (!parallaxBg) return;

  window.addEventListener('scroll', () => {
    const scrollPosition = window.scrollY;
    parallaxBg.style.transform = `translateY(${ scrollPosition * 0.3}px)`;
  });
}

/**
 * BUTTON HANDLERS
 */

// Handle opening game in new tab
function handleOpenGame(e) {
  e.preventDefault();

  // Get game URL from data attribute
  const gameUrl = e.currentTarget.getAttribute('data-game-url');
  if (!gameUrl || gameUrl === '#') {
    console.error('Game URL not found for direct open');
    return;
  }

  // Open game in new tab
  window.open(gameUrl, '_blank');
}

// Handle launching game in proxy
function handleProxyGame(e, customUrl) {
  e.preventDefault();

  // Get game URL from data attribute or use custom URL if provided
  const gameUrl = customUrl || e.currentTarget.getAttribute('data-game-url');
  if (!gameUrl || gameUrl === '#') {
    console.error('Game URL not found for proxy');
    return;
  }

  // Use existing auth controller check for logged in status
  const isLoggedIn = typeof window.isLoggedIn === 'function' ? window.isLoggedIn() : false;

  if (!isLoggedIn) {
    // Use existing auth controller to show login popup
    if (typeof window.showLoginPopup === 'function') {
      window.showLoginPopup();
    } else {
      // Fallback to auth modal if available
      const authModal = document.getElementById('authModal');
      if (authModal) {
        authModal.classList.add('active');

        // Setup close button
        const closeBtn = document.getElementById('closeAuthModal');
        if (closeBtn) {
          closeBtn.addEventListener('click', () => {
            authModal.classList.remove('active');
          });
        }

        // Store the URL to use after login
        window.pendingProxyUrl = gameUrl;
      } else {
        console.warn('Auth modal not found, launching game directly');
        launchGameInProxy(gameUrl);
      }
    }
  } else {
    // User is logged in, launch the game
    launchGameInProxy(gameUrl);
  }
}

// Launch game in proxy
function launchGameInProxy(gameUrl) {
  if (!gameUrl) return;

  // Method 1: Use the executeSearch function if available
  if (typeof window.executeSearch === 'function') {
    // Call executeSearch with proxy=true
    window.executeSearch(gameUrl, true);
    return;
  }

  // Method 2: Redirect to the &.html page with appropriate parameters
  const encodedUrl = encodeURIComponent(gameUrl);
  window.location.href = `/&.html ? q = ${ encodedUrl }& proxy=true`;
}

// Show error message
function showError(title, message) {
  const gameContainer = document.getElementById('game-container');
  if (!gameContainer) return;

  // Update the first element with error message
  const firstElement = gameContainer.firstElementChild;
  if (firstElement) {
    firstElement.innerHTML = `
      < div class="error-message" >
        <span class="material-symbols-outlined">error</span>
        <h3>${title}</h3>
        <p>${message}</p>
        <a href="/g.html" class="retry-button">
          <i class="fa-solid fa-gamepad"></i>
          Browse All Games
        </a>
      </ >
      `;
  }
}

/**
 * GAME DETAILS UPDATING WITH ENHANCED UI
 */

// Update game details with enhanced UI elements
function updateGameDetails(game, allGames) {
  if (!game) return;

  // Update title in the head section
  document.title = `Play ${ game.name } Unblocked on Flamepass`;

  // Update meta tags
  const metaDescription = document.querySelector('meta[name="description"]');
  if (metaDescription) {
    metaDescription.content = `Play ${ game.name } unblocked at school with Flamepass, the next gen school proxy.No downloads required, bypasses school filters, works directly in your browser.`;
  }

  // Update canonical link
  const canonicalLink = document.querySelector('link[rel="canonical"]');
  if (canonicalLink) {
    canonicalLink.href = `/ game / ${ game.slug } `;
  }

  // Get the game info section
  const gameInfo = document.querySelector('.game-info');
  if (!gameInfo) return;

  // Create enhanced game UI with parallax background
  const gameImageUrl = game.img || '/assets/game-placeholder.jpg';
  gameInfo.innerHTML = `
      < div class="game-parallax-container" >
      <div class="game-parallax-background" style="background-image: url('${gameImageUrl}')"></div>
      <div class="game-image-container">
        <img src="${gameImageUrl}" alt="${game.name}" class="game-detail-image">
      </div>
    </ >
    
    <h1>${game.name}</h1>
    
    <div class="game-tags">
      ${generateGameTags(game)}
    </div>
    
    <div class="game-metadata">
      <div class="metadata-item">
        <div class="metadata-icon">
          <i class="fa-solid fa-gamepad"></i>
        </div>
        <div>
          <span class="metadata-label">Category</span>
          <div class="metadata-value">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser'} Game</div>
        </div>
      </div>
      ${game.genre ? `
      <div class="metadata-item">
        <div class="metadata-icon">
          <i class="fa-solid fa-tag"></i>
        </div>
        <div>
          <span class="metadata-label">Genre</span>
          <div class="metadata-value">${game.genre}</div>
        </div>
      </div>
      ` : ''}
      ${game.publisher ? `
      <div class="metadata-item">
        <div class="metadata-icon">
          <i class="fa-solid fa-building"></i>
        </div>
        <div>
          <span class="metadata-label">Publisher</span>
          <div class="metadata-value">${game.publisher}</div>
        </div>
      </div>
      ` : ''}
      ${game.releaseDate ? `
      <div class="metadata-item">
        <div class="metadata-icon">
          <i class="fa-solid fa-calendar-days"></i>
        </div>
        <div>
          <span class="metadata-label">Release Date</span>
          <div class="metadata-value">${game.releaseDate}</div>
        </div>
      </div>
      ` : ''}
    </div>

    <div class="game-description">
      <h3>About ${game.name}</h3>
      <p>${game.description || `${game.name} is unblocked and playable right from your school or work browser. Flamepass allows you to bypass web filters and restrictions to enjoy your favorite games during breaks.`}</p>
      <p>Choose between directly opening the game in a new tab or using our secure Flamepass Proxy which can help bypass additional restrictions. The proxy option requires a free Flamepass account and adds an extra layer of protection.</p>
      <p>For the best experience, we recommend using the Flamepass Proxy option which helps evade content filtering systems and keeps your gaming activities private.</p>
    </div>

    <div class="game-buttons">
      <a href="#" class="play-button" id="openGameBtn" data-game-url="${game.url || '#'}">
        <i class="fa-solid fa-play"></i>
        Play Now
      </a>
      <a href="#" class="proxy-button" id="proxyGameBtn" data-game-url="${game.url || '#'}">
        <i class="fa-solid fa-shield-halved"></i>
        Play with Flamepass Proxy
      </a>
    </div>
    `;
    }
  }