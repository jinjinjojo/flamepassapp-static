document.addEventListener('DOMContentLoaded', () => {
  // Check if we're on a game page
  if (window.location.pathname.startsWith('/game/')) {
    // Check if we have server-rendered game data
    if (window.currentGame && window.currentGame.slug) {
      console.log('Using server-rendered game data:', window.currentGame);
      // Initialize just the dynamic parts since the page is already server-rendered
      initializeDynamicComponents(window.currentGame);
    } else {
      // Fall back to client-side rendering
      const slug = window.location.pathname.split('/').pop();
      initGamePage(slug);
    }
  }

  // Initialize the search functionality
  initSearch();

  // Initialize the scroll to top button
  initScrollToTop();

  // Setup keyboard shortcuts
  setupKeyboardShortcuts();

  // Initialize particles.js if available
  initializeParticles();
});

// Update the openIndexedDB function in game-page-handler.js to match the schema used in json-loader.js
function openIndexedDB() {
  return new Promise((resolve, reject) => {
    if (!window.indexedDB) {
      resolve(null);
      return;
    }

    const request = indexedDB.open('flamepass_games', 1);

    request.onerror = event => {
      console.error('IndexedDB error:', event.target.error);
      resolve(null);
    };

    request.onsuccess = event => {
      resolve(event.target.result);
    };

    request.onupgradeneeded = event => {
      const db = event.target.result;

      // Create consistent store names with json-loader.js
      if (!db.objectStoreNames.contains('items')) {
        db.createObjectStore('items', { keyPath: 'id' });
      }

      if (!db.objectStoreNames.contains('meta')) {
        db.createObjectStore('meta', { keyPath: 'key' });
      }
    };
  });
}

// And replace the getAllGamesFromDB function to use the approach from json-loader.js
function getAllGamesFromDB(db) {
  return new Promise((resolve, reject) => {
    if (!db) {
      console.error("DB object is null in getGamesFromDB");
      resolve([]);
      return;
    }

    console.log("Starting getGamesFromDB");

    try {
      // First get the order array
      const metaTransaction = db.transaction(['meta'], 'readonly');
      const metaStore = metaTransaction.objectStore('meta');
      const orderRequest = metaStore.get('gamesOrder');

      orderRequest.onsuccess = async () => {
        const orderArray = orderRequest.result ? orderRequest.result.value : null;

        if (orderArray) {
          console.log("Retrieved order array with", orderArray.length, "entries");
        } else {
          console.warn("No order array found in IndexedDB");
        }

        // Now get all the games
        const transaction = db.transaction(['items'], 'readonly');
        const store = transaction.objectStore('items');
        const gamesRequest = store.getAll();

        gamesRequest.onsuccess = () => {
          const games = gamesRequest.result;
          console.log("Retrieved", games.length, "games from IndexedDB");

          // If we have an order array, use it to sort the games
          if (orderArray && Array.isArray(orderArray)) {
            // Create a map of id -> game for efficient lookup
            const gamesMap = {};
            games.forEach(game => {
              gamesMap[game.id] = game;
            });

            // Use the orderArray to sort games by their original index
            const orderedGames = orderArray
              .sort((a, b) => a.originalIndex - b.originalIndex)
              .map(item => gamesMap[item.id])
              .filter(game => game !== undefined); // Filter out any missing games

            console.log("Returning", orderedGames.length, "ordered games");

            // Check for games not in the order array
            const missingGameIds = games
              .filter(game => !orderArray.some(item => item.id === game.id))
              .map(game => game.id);

            if (missingGameIds.length > 0) {
              console.log("Found", missingGameIds.length, "games not in the order array");
              // Add these games to the end
              const remainingGames = games.filter(game =>
                !orderArray.some(item => item.id === game.id)
              );
              orderedGames.push(...remainingGames);
            }

            resolve(orderedGames);
          } else if (games.length > 0 && games[0]._originalIndex !== undefined) {
            // Fallback: sort by the _originalIndex property directly
            console.log("Fallback: sorting by _originalIndex property");
            const sortedGames = [...games].sort((a, b) => {
              return (a._originalIndex || 0) - (b._originalIndex || 0);
            });

            resolve(sortedGames);
          } else {
            // If all else fails, return games as-is
            console.warn("No order information found, returning games as-is");
            resolve(games);
          }
        };

        gamesRequest.onerror = event => {
          console.error('Error getting games:', event.target.error);
          resolve([]);
        };
      };

      orderRequest.onerror = event => {
        console.error('Error getting games order:', event.target.error);
        // Fallback: try to get games and sort by _originalIndex
        const transaction = db.transaction(['items'], 'readonly');
        const store = transaction.objectStore('items');
        const request = store.getAll();

        request.onsuccess = () => {
          const games = request.result;
          if (games.length > 0 && games[0]._originalIndex !== undefined) {
            const sortedGames = [...games].sort((a, b) => {
              return (a._originalIndex || 0) - (b._originalIndex || 0);
            });
            resolve(sortedGames);
          } else {
            resolve(games);
          }
        };

        request.onerror = () => {
          resolve([]);
        };
      };
    } catch (error) {
      console.error('Error in getGamesFromDB:', error);
      resolve([]);
    }
  });
}

// Modify this function in game-page-handler.js to use the approach from json-loader.js
function storeGamesInDB(db, games) {
  return new Promise((resolve, reject) => {
    if (!db) {
      console.error("DB object is null in storeGamesInDB");
      resolve();
      return;
    }

    console.log("Starting storeGamesInDB with", games.length, "games");

    try {
      // Create a transaction that includes both object stores
      const transaction = db.transaction(['items', 'meta'], 'readwrite');
      const store = transaction.objectStore('items');
      const metaStore = transaction.objectStore('meta');

      // Clear existing data first
      store.clear();

      // Create an explicit array of indices for order preservation
      const orderArray = games.map((game, index) => {
        // Ensure each game has a unique ID
        if (!game.id) {
          if (game.slug) {
            game.id = game.slug;
          } else if (game.name) {
            game.id = game.name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '-');
          } else {
            game.id = `game-${Math.random().toString(36).substring(2, 7)}`;
          }
        }

        // Return the ID and original index
        return {
          id: game.id,
          originalIndex: index
        };
      });

      // Store the order array
      metaStore.put({
        key: 'gamesOrder',
        value: orderArray
      });

      // Update timestamp
      metaStore.put({ key: 'lastUpdate', value: Date.now() });

      // Add all games individually with originalIndex property
      let completed = 0;
      games.forEach((game, index) => {
        // Store originalIndex directly in the game object
        game._originalIndex = index;

        const request = store.put(game);

        request.onsuccess = () => {
          completed++;
          if (completed === games.length) {
            console.log(`Completed storing all ${completed} games with order preservation`);
          }
        };

        request.onerror = event => {
          console.error('Error storing game:', event.target.error);
          completed++;
        };
      });

      transaction.oncomplete = () => {
        console.log('Transaction completed: stored games with order preservation');
        resolve();
      };

      transaction.onerror = event => {
        console.error('Transaction error:', event.target.error);
        reject(event.target.error);
      };
    } catch (error) {
      console.error('Error starting transaction:', error);
      reject(error);
    }
  });
}

// Update the fetchGames function to use the standardized approach
async function fetchGames() {
  // Try to get from window cache first (may be set by other scripts)
  if (window.allGames && Array.isArray(window.allGames) && window.allGames.length > 0) {
    return window.allGames;
  }

  // Try to get from memory cache
  if (window.cache && window.cache.games && Array.isArray(window.cache.games)) {
    return window.cache.games;
  }

  // Try to get from IndexedDB
  try {
    const db = await openIndexedDB();
    if (db) {
      const games = await getAllGamesFromDB(db);
      if (games && games.length > 0) {
        return games;
      }
    }
  } catch (e) {
    console.warn('Error loading games from IndexedDB:', e);
  }

  // Last resort: fetch from server and store in IndexedDB
  try {
    const response = await fetch('/json/g.json');
    if (!response.ok) throw new Error('Failed to fetch games data');

    const data = await response.json();

    // Store in IndexedDB for future use
    try {
      const db = await openIndexedDB();
      if (db) {
        await storeGamesInDB(db, data);
        console.log('Successfully stored games in IndexedDB');
      }
    } catch (e) {
      console.warn('Error storing games in IndexedDB:', e);
    }

    return data;
  } catch (error) {
    console.error('Error fetching games data:', error);
    return [];
  }
}

function updateGameDetails(game, allGames) {
  if (!game) return;

  const gameContainer = document.getElementById('game-container');
  const gameInfoSection = gameContainer.querySelector('.game-info');

  if (!gameInfoSection) return;

  // Clear any loading state
  gameInfoSection.innerHTML = '';

  // Create parallax background
  const parallaxContainer = document.createElement('div');
  parallaxContainer.className = 'game-parallax-container';

  const parallaxBackground = document.createElement('div');
  parallaxBackground.className = 'game-parallax-background';
  parallaxBackground.style.backgroundImage = `url('${game.img || '/assets/game-placeholder.jpg'}')`;

  const imageContainer = document.createElement('div');
  imageContainer.className = 'game-image-container';
  imageContainer.innerHTML = `<img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" class="game-detail-image">`;

  parallaxContainer.appendChild(parallaxBackground);
  parallaxContainer.appendChild(imageContainer);
  gameInfoSection.appendChild(parallaxContainer);

  // Game title
  const title = document.createElement('h1');
  title.textContent = game.name;
  gameInfoSection.appendChild(title);

  // Game tags
  if (game.tags && Array.isArray(game.tags) && game.tags.length > 0) {
    const tagsDiv = document.createElement('div');
    tagsDiv.className = 'game-tags';
    tagsDiv.innerHTML = game.tags.map(tag => `<span class="game-tag">${tag}</span>`).join('');
    gameInfoSection.appendChild(tagsDiv);
  }

  // Game metadata
  const metadataDiv = document.createElement('div');
  metadataDiv.className = 'game-metadata';

  // Category metadata
  metadataDiv.innerHTML += `
    <div class="metadata-item">
      <div class="metadata-icon">
        <i class="fa-solid fa-gamepad"></i>
      </div>
      <div>
        <span class="metadata-label">Category</span>
        <div class="metadata-value">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser'} Game</div>
      </div>
    </div>
  `;

  // Genre metadata (if available)
  if (game.genre) {
    metadataDiv.innerHTML += `
      <div class="metadata-item">
        <div class="metadata-icon">
          <i class="fa-solid fa-tag"></i>
        </div>
        <div>
          <span class="metadata-label">Genre</span>
          <div class="metadata-value">${game.genre}</div>
        </div>
      </div>
    `;
  }

  // Publisher metadata (if available)
  if (game.publisher) {
    metadataDiv.innerHTML += `
      <div class="metadata-item">
        <div class="metadata-icon">
          <i class="fa-solid fa-building"></i>
        </div>
        <div>
          <span class="metadata-label">Publisher</span>
          <div class="metadata-value">${game.publisher}</div>
        </div>
      </div>
    `;
  }

  // Release date metadata (if available)
  if (game.releaseDate) {
    metadataDiv.innerHTML += `
      <div class="metadata-item">
        <div class="metadata-icon">
          <i class="fa-solid fa-calendar-days"></i>
        </div>
        <div>
          <span class="metadata-label">Release Date</span>
          <div class="metadata-value">${game.releaseDate}</div>
        </div>
      </div>
    `;
  }

  gameInfoSection.appendChild(metadataDiv);

  // Game description
  const descriptionDiv = document.createElement('div');
  descriptionDiv.className = 'game-description';
  descriptionDiv.innerHTML = `
    <h3>About ${game.name}</h3>
    <p>${game.description || `${game.name} is a ${game.category || 'browser'} game available to play unblocked at school.`}</p>
    <p>Choose between directly opening the game in a new tab or using our secure Flamepass Proxy which
        can help bypass additional restrictions. The proxy option requires a free Flamepass account and
        adds an extra layer of protection.</p>
    <p>For the best experience, we recommend using the Flamepass Proxy option which helps evade content
        filtering systems and keeps your gaming activities private.</p>
  `;
  gameInfoSection.appendChild(descriptionDiv);

  // Game buttons - only for browser and emulator games, not for cloud games
  if (game.category !== 'cloud') {
    const buttonsDiv = document.createElement('div');
    buttonsDiv.className = 'game-buttons';
    buttonsDiv.innerHTML = `
      <a href="${game.url || '#'}" class="play-button" id="openGameBtn" data-game-url="${game.url || '#'}">
        <i class="fa-solid fa-play"></i>
        Play Now
      </a>
      <a href="#" class="proxy-button" id="proxyGameBtn" data-game-url="${game.url || '#'}">
        <i class="fa-solid fa-shield-halved"></i>
        Play with Flamepass Proxy
      </a>
    `;
    gameInfoSection.appendChild(buttonsDiv);
  }
}
// Update setupButtonHandlers in games page to use the global auth modal
function setupButtonHandlers(game) {
  if (!game) return;

  // Direct play button
  const openGameBtn = document.getElementById('openGameBtn');
  if (openGameBtn) {
    openGameBtn.addEventListener('click', (e) => {
      // Track play action for analytics
      if (window.gtag) {
        gtag('event', 'play_game', {
          'game_name': game.name,
          'game_category': game.category,
          'method': 'direct'
        });
      }
    });
  }

  // Proxy play button
  const proxyGameBtn = document.getElementById('proxyGameBtn');
  if (proxyGameBtn) {
    proxyGameBtn.addEventListener('click', (e) => {
      e.preventDefault();

      // Get game URL from data attribute
      const gameUrl = proxyGameBtn.getAttribute('data-game-url');

      // Check if user is logged in (using auth-controller.js function)
      const isLoggedIn = window.isLoggedIn ? window.isLoggedIn() : false;

      if (isLoggedIn) {
        // User is logged in, redirect to proxy
        window.open(`/@/index.html?uul=${encodeURIComponent(gameUrl)}`, '_blank');

        // Track play action for analytics
        if (window.gtag) {
          gtag('event', 'play_game', {
            'game_name': game.name,
            'game_category': game.category,
            'method': 'proxy'
          });
        }
      } else {
        // User is not logged in, show auth modal from auth-controller.js
        if (window.showAuthModal) {
          window.showAuthModal();
        } else if (window.showLoginPopup) {
          window.showLoginPopup();
        }

        // Track auth prompt
        if (window.gtag) {
          gtag('event', 'auth_prompt', {
            'trigger': 'proxy_play',
            'game_name': game.name
          });
        }
      }
    });
  }
}

// Update cloud provider proxy buttons to use the global auth system
function setupCloudProviders(game) {
  if (!game || !game.serviceProviders) return;

  const providersContainer = document.getElementById('cloud-providers-container');
  const providersGrid = document.getElementById('providers-grid');

  if (!providersContainer || !providersGrid) return;

  // Clear existing providers
  providersGrid.innerHTML = '';

  // Loop through each service provider
  Object.entries(game.serviceProviders).forEach(([provider, info]) => {
    const providerCard = document.createElement('div');
    providerCard.className = 'provider-card';

    // Set logo path based on provider name
    const logoPath = `/assets/providers/${provider.toLowerCase()}.png`;

    // Build provider card according to paste.txt template
    providerCard.innerHTML = `
      <div class="provider-logo">
        <img src="${logoPath}" alt="${provider}" onerror="this.src='/assets/logo.webp'">
      </div>
      <h3 class="provider-name">${provider}</h3>
      <div class="provider-buttons">
        <a href="${info.url}" target="_blank" class="provider-direct-button">
          <i class="fa-solid fa-external-link-alt"></i>
          Direct
        </a>
        <a href="#" class="provider-proxy-button" data-url="${encodeURIComponent(info.url)}">
          <i class="fa-solid fa-shield-alt"></i>
          Proxy
        </a>
      </div>
    `;

    providersGrid.appendChild(providerCard);
  });

  // Add event listeners to proxy buttons
  const proxyButtons = providersGrid.querySelectorAll('.provider-proxy-button');
  proxyButtons.forEach(button => {
    button.addEventListener('click', (e) => {
      e.preventDefault();

      // Get provider URL
      const providerUrl = button.getAttribute('data-url');

      // Check if user is logged in
      const isLoggedIn = window.isLoggedIn ? window.isLoggedIn() : false;

      if (isLoggedIn) {
        // User is logged in, redirect to proxy
        window.open(`/@/index.html?uul=${providerUrl}`, '_blank');
      } else {
        // User is not logged in, show auth modal from auth-controller.js
        if (window.showAuthModal) {
          window.showAuthModal();
        } else if (window.showLoginPopup) {
          window.showLoginPopup();
        }
      }
    });
  });

  // Show the providers section
  providersContainer.style.display = game.category === 'cloud' ? 'block' : 'none';
}
async function initGamePage(slug) {
  if (!slug) return;

  try {
    // Show loading state
    showLoading();

    // Get game data
    const allGames = await fetchGames();
    const currentGame = allGames.find(game => game.slug === slug);

    // Store game data globally for other scripts
    window.currentGame = currentGame;
    window.allGames = allGames;

    if (!currentGame) {
      showError('Game Not Found', 'Sorry, we couldn\'t find the game you\'re looking for.');
      return;
    }

    // Update document title
    document.title = `Play ${currentGame.name} Unblocked on Flamepass`;

    // Update meta tags for SEO
    updateMetaTags(currentGame);

    // Update game details in the existing container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      updateGameDetails(currentGame, allGames);
    }

    // Setup button event handlers
    setupButtonHandlers(currentGame);

    // Setup cloud provider buttons if applicable
    if (currentGame.category === 'cloud' && currentGame.serviceProviders) {
      setupCloudProviders(currentGame);
    }

    // Initialize parallax effect
    initParallaxEffect();

    // Initialize components with all categories
    const categories = ['browser', 'emulator', 'cloud'];
    const currentCategory = currentGame.category || 'browser';

    // First show games from the same category
    updateCategoryBasedGames(currentGame, allGames, currentCategory);

    // Then show trending games
    updateTrendingGames(allGames);

    // Then show games from other categories
    categories.forEach(category => {
      if (category !== currentCategory) {
        updateCategoryGames(currentGame, allGames, category);
      }
    });

  } catch (error) {
    console.error('Error initializing game page:', error);
    showError('Error Loading Game', 'There was a problem loading the game details. Please try again later.');
  }
}

function updateMetaTags(game) {
  // Update meta description
  const metaDescription = document.querySelector('meta[name="description"]');
  if (metaDescription) {
    metaDescription.setAttribute('content',
      `Play ${game.name} unblocked at school with Flamepass, the next gen school proxy. No downloads required, bypasses school filters, works directly in your browser.`
    );
  }

  // Update meta keywords
  const metaKeywords = document.querySelector('meta[name="keywords"]');
  if (metaKeywords) {
    metaKeywords.setAttribute('content',
      `Unblocked Games, School Games, ${game.name} Unblocked, Bypass School Filters, Flamepass`
    );
  }

  // Update og:title
  const ogTitle = document.querySelector('meta[property="og:title"]');
  if (ogTitle) {
    ogTitle.setAttribute('content', `Play ${game.name} Unblocked | Flamepass`);
  }

  // Update canonical URL
  const canonical = document.querySelector('link[rel="canonical"]');
  if (canonical) {
    canonical.setAttribute('href', `/game/${game.slug}`);
  }
}
function initParallaxEffect() {
  const parallaxBackground = document.querySelector('.game-parallax-background');
  if (!parallaxBackground) return;

  // Add scroll event listener for parallax effect
  window.addEventListener('scroll', () => {
    const scrollPosition = window.scrollY;
    const translateY = Math.min(scrollPosition * 0.2, 100); // Limit max translation

    // Apply parallax effect
    parallaxBackground.style.transform = `translateY(${translateY}px)`;
    parallaxBackground.style.opacity = Math.max(1 - (scrollPosition * 0.002), 0.3); // Fade out slightly on scroll
  });
}

function initializeParticles() {
  if (window.particlesJS && document.getElementById('particles-js')) {
    particlesJS('particles-js', {
      particles: {
        number: { value: 80, density: { enable: true, value_area: 800 } },
        color: { value: '#ffffff' },
        shape: { type: 'circle' },
        opacity: { value: 0.5, random: true },
        size: { value: 3, random: true },
        line_linked: { enable: false },
        move: {
          enable: true,
          speed: 0.3,
          direction: 'top',
          random: true,
          straight: false,
          out_mode: 'out'
        }
      }
    });
  }
}

function showLoading() {
  const gameInfoSection = document.querySelector('.game-info');
  if (!gameInfoSection) return;

  gameInfoSection.innerHTML = `
    <div class="loading-container">
      <div class="game-loader">
        <svg viewBox="0 0 80 80">
          <circle cx="40" cy="40" r="32" class="loader-circle"></circle>
        </svg>
      </div>
      <h2 class="loading-text">Loading Game Details</h2>
      <p class="loading-subtext">Preparing your unblocked gaming experience...</p>
    </div>
  `;
}

function showError(title, message) {
  const gameContainer = document.getElementById('game-container');
  if (!gameContainer) return;

  // Update the first element with error message
  const firstElement = gameContainer.firstElementChild;
  if (firstElement) {
    firstElement.innerHTML = `
      <div class="error-message">
        <span class="material-symbols-outlined">error</span>
        <h3>${title}</h3>
        <p>${message}</p>
        <a href="/g.html" class="retry-button">
          <i class="fa-solid fa-gamepad"></i>
          Browse All Games
        </a>
      </div>
    `;
  }
}

function initializeDynamicComponents(currentGame) {
  // Initialize parallax effect
  initParallaxEffect();

  // Initialize unblock tips section
  initUnblockTipsSection();

  // Add event listeners to buttons
  setupButtonHandlers(currentGame);

  // Setup cloud provider buttons if applicable
  if (currentGame.category === 'cloud' && currentGame.serviceProviders) {
    setupCloudProviders(currentGame);
  }

  // Fetch all games for related content
  fetchGames().then(allGames => {
    // Store games data for other scripts
    window.allGames = allGames;

    // Update related games sections based on categories
    const categories = ['browser', 'emulator', 'cloud'];
    const currentCategory = currentGame.category || 'browser';

    // First show games from the same category
    updateCategoryBasedGames(currentGame, allGames, currentCategory);

    // Then show trending games
    updateTrendingGames(allGames);

    // Then show games from other categories
    categories.forEach(category => {
      if (category !== currentCategory) {
        updateCategoryGames(currentGame, allGames, category);
      }
    });

  }).catch(error => {
    console.error('Error fetching games for dynamic components:', error);
  });
}
function getRandomGames(games, count) {
  if (!Array.isArray(games) || games.length === 0) {
    return [];
  }

  // Shuffle array
  const shuffled = [...games].sort(() => 0.5 - Math.random());

  // Return up to count games
  return shuffled.slice(0, Math.min(count, shuffled.length));
}

function updateGameGrid(grid, games) {
  if (!grid || !Array.isArray(games)) return;

  // Clear grid first
  grid.innerHTML = '';

  // Add game cards to grid
  games.forEach(game => {
    const gameCard = document.createElement('a');
    gameCard.href = `/game/${game.slug}`;
    gameCard.className = 'game-card';

    gameCard.innerHTML = `
      <div class="game-card-image">
        <img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" loading="lazy">
      </div>
      <div class="game-card-info">
        <h3>${game.name}</h3>
        <div class="game-card-meta">
          <span class="category-pill">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser'}</span>
        </div>
      </div>
    `;

    grid.appendChild(gameCard);
  });
}

function updateCategoryBasedGames(game, allGames, category) {
  if (!game || !allGames || !category) return;

  // Create container if not exists
  let container = document.querySelector('.category-games-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'category-games-container';

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // Filter games from the same category, but not the current game
  const categoryGames = allGames.filter(g =>
    g.category === category && g.slug !== game.slug
  );

  // If no games, hide container
  if (categoryGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games from category (up to 4)
  const gamesToShow = getRandomGames(categoryGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';
  header.innerHTML = `
    <h2>More ${category.charAt(0).toUpperCase() + category.slice(1)} Games</h2>
    <a href="/g.html?category=${category}" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}
function updateTrendingGames(allGames) {
  if (!allGames) return;

  // Create container if not exists
  let container = document.querySelector('.trending-games-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'trending-games-container';

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // If no games, hide container
  if (allGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games (up to 4) - in a real app, this would be most popular
  const gamesToShow = getRandomGames(allGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';
  header.innerHTML = `
    <h2>Trending Games</h2>
    <a href="/g.html?trending=true" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}

function updateCategoryGames(game, allGames, category) {
  if (!game || !allGames || !category) return;

  // Create container if not exists
  let container = document.querySelector(`.${category}-games-container`);
  if (!container) {
    container = document.createElement('div');
    container.className = `${category}-games-container`;

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // Filter games from the specific category, but not the current game
  const categoryGames = allGames.filter(g =>
    g.category === category && g.slug !== game.slug
  );

  // If no games, hide container
  if (categoryGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games from category (up to 4)
  const gamesToShow = getRandomGames(categoryGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';

  // Customize title based on category
  let title;
  switch (category) {
    case 'browser':
      title = 'HTML5 Browser Games';
      break;
    case 'emulator':
      title = 'Emulator Games';
      break;
    case 'cloud':
      title = 'Cloud Gaming';
      break;
    default:
      title = `${category.charAt(0).toUpperCase() + category.slice(1)} Games`;
  }

  header.innerHTML = `
    <h2>${title}</h2>
    <a href="/g.html?category=${category}" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}
function initSearch() {
  const searchTrigger = document.getElementById('searchTrigger');
  const searchModal = document.getElementById('searchModal');
  const closeSearch = document.getElementById('closeSearch');
  const searchInput = document.getElementById('searchInput');
  const searchResults = document.getElementById('searchResults');

  if (!searchTrigger || !searchModal || !closeSearch || !searchInput || !searchResults) {
    console.warn('Search elements not found. Search functionality disabled.');
    return;
  }

  // Open search modal
  searchTrigger.addEventListener('click', () => {
    openSearchModal();
  });

  // Close search modal
  closeSearch.addEventListener('click', () => {
    closeSearchModal();
  });

  // Click outside to close
  searchModal.addEventListener('click', (e) => {
    if (e.target === searchModal) {
      closeSearchModal();
    }
  });

  // Search input handler with debounce
  let debounceTimer;
  searchInput.addEventListener('input', () => {
    clearTimeout(debounceTimer);

    const query = searchInput.value.trim();

    if (query.length < 2) {
      searchResults.innerHTML = `
        <div class="search-message">
          <span class="material-symbols-outlined">search</span>
          <p>Type at least 2 characters to search</p>
        </div>
      `;
      return;
    }

    // Set loading state
    searchResults.innerHTML = `
      <div class="search-message">
        <div class="loader" style="width: 30px; height: 30px;">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="32" class="loader-circle" />
          </svg>
        </div>
        <p>Searching...</p>
      </div>
    `;

    // Debounce search request
    debounceTimer = setTimeout(() => {
      performSearch(query.toLowerCase());
    }, 300);
  });
}

function openSearchModal() {
  const searchModal = document.getElementById('searchModal');
  const searchInput = document.getElementById('searchInput');

  if (!searchModal || !searchInput) return;

  searchModal.classList.add('active');

  // Focus input after animation
  setTimeout(() => {
    searchInput.focus();
  }, 100);

  // Disable body scroll
  document.body.style.overflow = 'hidden';
}

function closeSearchModal() {
  const searchModal = document.getElementById('searchModal');
  const searchInput = document.getElementById('searchInput');

  if (!searchModal || !searchInput) return;

  searchModal.classList.remove('active');
  searchInput.value = '';

  // Enable body scroll
  document.body.style.overflow = '';
}
async function performSearch(query) {
  const searchResults = document.getElementById('searchResults');

  if (!searchResults) return;

  try {
    // Get all games
    const allGames = await fetchGames();

    console.log(`Searching through ${allGames.length} games for "${query}"`);

    // Filter games based on query
    const filteredGames = allGames.filter(game =>
      (game.name && game.name.toLowerCase().includes(query)) ||
      (game.description && game.description.toLowerCase().includes(query)) ||
      (game.category && game.category.toLowerCase().includes(query)) ||
      (game.publisher && game.publisher.toLowerCase().includes(query)) ||
      (game.tags && Array.isArray(game.tags) && game.tags.some(tag => tag.toLowerCase().includes(query)))
    );

    // Display results
    if (filteredGames.length === 0) {
      searchResults.innerHTML = `
        <div class="search-message">
          <span class="material-symbols-outlined">sentiment_dissatisfied</span>
          <p>No games found matching "${query}"</p>
        </div>
      `;
    } else {
      searchResults.innerHTML = '';

      filteredGames.slice(0, 8).forEach(game => {
        const resultItem = document.createElement('a');
        resultItem.href = `/game/${game.slug}`;
        resultItem.className = 'search-result-item';

        resultItem.innerHTML = `
          <div class="search-result-image">
            <img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" loading="lazy">
          </div>
          <div class="search-result-info">
            <h3>${game.name}</h3>
            <div class="search-result-meta">
              <span class="category-pill">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser Game'}</span>
              ${game.publisher ? `<span class="publisher">${game.publisher}</span>` : ''}
            </div>
          </div>
        `;

        searchResults.appendChild(resultItem);
      });

      if (filteredGames.length > 8) {
        const viewAll = document.createElement('a');
        viewAll.href = `/g.html?search=${encodeURIComponent(query)}`;
        viewAll.className = 'view-all-results';
        viewAll.innerHTML = `View all ${filteredGames.length} results <span class="material-symbols-outlined">arrow_forward</span>`;
        searchResults.appendChild(viewAll);
      }
    }
  } catch (error) {
    console.error('Error during search:', error);
    searchResults.innerHTML = `
      <div class="search-message">
        <span class="material-symbols-outlined">error</span>
        <p>An error occurred while searching</p>
      </div>
    `;
  }
}
function initScrollToTop() {
  const scrollTopBtn = document.getElementById('scrollTopBtn');

  if (!scrollTopBtn) return;

  // Show/hide button based on scroll position
  window.addEventListener('scroll', () => {
    if (document.documentElement.scrollTop > 300) {
      scrollTopBtn.classList.add('visible');
    } else {
      scrollTopBtn.classList.remove('visible');
    }
  });

  // Scroll to top when clicked
  scrollTopBtn.addEventListener('click', () => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  });
}

function setupKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    // Open search with Cmd+K or Ctrl+K
    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
      e.preventDefault();
      openSearchModal();
    }

    // Close search with Escape
    if (e.key === 'Escape') {
      closeSearchModal();

      // Also close auth modal if open
      const authModal = document.getElementById('authModal');
      if (authModal && authModal.classList.contains('active')) {
        authModal.classList.remove('active');
      }
    }
  });
}
function initUnblockTipsSection() {
  const unblockInfoSection = document.querySelector('.unblock-info-section');

  if (!unblockInfoSection) return;

  // Clear any placeholder content
  unblockInfoSection.innerHTML = '';

  // Create header
  const header = document.createElement('h2');
  header.textContent = 'How to Play Games Unblocked at School';
  unblockInfoSection.appendChild(header);

  // Create description
  const description = document.createElement('p');
  description.textContent = 'Flamepass provides multiple ways to access blocked content at school or work. Here are some tips to enhance your experience:';
  unblockInfoSection.appendChild(description);

  // Create tips container
  const tipsContainer = document.createElement('div');
  tipsContainer.className = 'unblock-tips';

  // Define tips
  const tips = [
    {
      icon: 'fa-shield',
      title: 'Use Flamepass Proxy',
      description: 'Our secure proxy can bypass most school filters and keeps your gaming activity hidden from monitoring systems.'
    },
    {
      icon: 'fa-clock',
      title: 'Private Browsing',
      description: 'Use incognito or private browsing mode to prevent browsing history from being stored on school computers.'
    },
    {
      icon: 'fa-bolt',
      title: 'Alternative Links',
      description: 'Check our Discord for alternative domain links if the main Flamepass site gets blocked at your school.'
    },
    {
      icon: 'fa-wifi',
      title: 'VPN Alternatives',
      description: 'If proxy isn\'t working, try using a browser-based VPN extension or Flamepass\'s built-in tunneling system.'
    }
  ];

  // Add tips to container
  tips.forEach(tip => {
    const tipCard = document.createElement('div');
    tipCard.className = 'tip-card';

    tipCard.innerHTML = `
      <div class="tip-icon">
        <i class="fa-solid ${tip.icon}"></i>
      </div>
      <h3 class="tip-title">${tip.title}</h3>
      <p class="tip-description">${tip.description}</p>
    `;

    tipsContainer.appendChild(tipCard);
  });

  unblockInfoSection.appendChild(tipsContainer);

  // Add advanced tips section
  const advancedTips = document.createElement('div');
  advancedTips.className = 'advanced-tips';

  advancedTips.innerHTML = `
    <h3>Advanced Unblocking Methods</h3>
    <div class="advanced-tips-grid">
      <div class="advanced-tip">
        <div class="advanced-tip-icon">
          <i class="fa-solid fa-user-secret"></i>
        </div>
        <div class="advanced-tip-content">
          <h4>User Agent Switching</h4>
          <p>Some school filters rely on browser identification. Try changing your user agent to appear as a different device.</p>
        </div>
      </div>
      
      <div class="advanced-tip">
        <div class="advanced-tip-icon">
          <i class="fa-solid fa-server"></i>
        </div>
        <div class="advanced-tip-content">
          <h4>DNS Changing</h4>
          <p>Change your DNS settings to bypass basic network restrictions (works best on personal devices).</p>
        </div>
      </div>
      
      <div class="advanced-tip">
        <div class="advanced-tip-icon">
          <i class="fa-solid fa-window-restore"></i>
        </div>
        <div class="advanced-tip-content">
          <h4>About:blank Cloaking</h4>
          <p>Launch games through an about:blank page to hide the actual URL from basic monitoring systems.</p>
        </div>
      </div>
      
      <div class="advanced-tip">
        <div class="advanced-tip-icon">
          <i class="fa-solid fa-key"></i>
        </div>
        <div class="advanced-tip-content">
          <h4>Browser Extension Cache</h4>
          <p>Install extensions that cache games locally, allowing you to play offline when restrictions tighten.</p>
        </div>
      </div>
    </div>
  `;

  unblockInfoSection.appendChild(advancedTips);
}
