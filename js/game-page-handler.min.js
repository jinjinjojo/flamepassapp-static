document.addEventListener('DOMContentLoaded', () => {
  // Check if we're on a game page
  if (window.location.pathname.startsWith('/game/')) {
    // Check if we have server-rendered game data
    if (window.currentGame && window.currentGame.slug) {
      console.log('Using server-rendered game data:', window.currentGame);
      // Initialize just the dynamic parts since the page is already server-rendered
      initializeDynamicComponents(window.currentGame);
    } else {
      // Fall back to client-side rendering
      const slug = window.location.pathname.split('/').pop();
      initGamePage(slug);
    }
  }

  // Initialize the search functionality
  initSearch();

  // Initialize the scroll to top button
  initScrollToTop();

  // Setup keyboard shortcuts
  setupKeyboardShortcuts();

  // Initialize particles.js if available
  initializeParticles();
});


// Helper function to open IndexedDB
function openIndexedDB() {
  return new Promise((resolve, reject) => {
    if (!window.indexedDB) {
      resolve(null);
      return;
    }

    const request = indexedDB.open('flamepass_games', 1);

    request.onerror = event => {
      console.error('IndexedDB error:', event.target.error);
      resolve(null);
    };

    request.onsuccess = event => {
      resolve(event.target.result);
    };

    request.onupgradeneeded = event => {
      const db = event.target.result;

      // Create items store with id as keyPath (changed from games)
      if (!db.objectStoreNames.contains('items')) {
        db.createObjectStore('items', { keyPath: 'id' });
      }

      // Create meta store if needed
      if (!db.objectStoreNames.contains('meta')) {
        db.createObjectStore('meta', { keyPath: 'key' });
      }
    };
  });
}

// Helper function to get all games from IndexedDB
function getAllGamesFromDB(db) {
  return new Promise((resolve, reject) => {
    // Using the getAllItemsFromDB function approach from json-loader.js
    if (!db) {
      resolve([]);
      return;
    }

    // Make sure the store exists before trying to use it
    if (!db.objectStoreNames.contains('items')) {
      console.warn('Store items not found in database');
      resolve([]);
      return;
    }

    const transaction = db.transaction(['items'], 'readonly');
    const store = transaction.objectStore('items');

    // For games specifically, try to maintain insertion order
    // Use cursor to retrieve in insertion order
    const items = [];
    const cursorRequest = store.openCursor();

    cursorRequest.onsuccess = (event) => {
      const cursor = event.target.result;
      if (cursor) {
        items.push(cursor.value);
        cursor.continue();
      } else {
        // All items collected
        resolve(items);
      }
    };

    cursorRequest.onerror = (event) => {
      console.error(`Error getting items with cursor:`, event.target.error);
      // Fall back to getAll() if cursor fails
      const getAllRequest = store.getAll();
      getAllRequest.onsuccess = () => resolve(getAllRequest.result);
      getAllRequest.onerror = () => resolve([]);
    };
  });
}

// Function to store games in IndexedDB
function storeGamesInDB(db, games) {
  return new Promise((resolve, reject) => {
    if (!db) {
      console.error("DB object is null in storeGamesInDB");
      resolve();
      return;
    }

    console.log("Storing games with order preservation:", games.length, "games");

    try {
      const transaction = db.transaction(['items', 'meta'], 'readwrite');
      const store = transaction.objectStore('items');
      const metaStore = transaction.objectStore('meta');

      // Clear existing data
      store.clear();

      // Create a simple ordered array of game IDs in their original order
      const gameIds = games.map((game, index) => {
        // Ensure each game has a unique ID
        if (!game.id) {
          if (game.slug) {
            game.id = game.slug;
          } else if (game.name) {
            game.id = game.name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '-');
          } else {
            game.id = `game-${Math.random().toString(36).substring(2, 7)}`;
          }
        }

        // Store the original index directly in the game object
        game._originalIndex = index;

        return game.id;
      });

      // Store the simple ordered array of game IDs
      metaStore.put({
        key: 'gamesOrder',
        value: gameIds
      });

      // Update timestamp
      metaStore.put({ key: 'lastUpdate', value: Date.now() });

      // Add all games
      let completed = 0;
      games.forEach(game => {
        const request = store.put(game);

        request.onsuccess = () => {
          completed++;
          if (completed === games.length) {
            console.log(`Completed storing all ${completed} games with order preservation`);
          }
        };

        request.onerror = event => {
          console.error('Error storing game:', event.target.error);
          completed++;
        };
      });

      transaction.oncomplete = () => {
        console.log('Transaction completed: stored games with order preservation');
        resolve();
      };

      transaction.onerror = event => {
        console.error('Transaction error:', event.target.error);
        reject(event.target.error);
      };
    } catch (error) {
      console.error('Error starting transaction:', error);
      reject(error);
    }
  });
}

// Function to fetch games data from various sources
async function fetchGames() {
  // Try to get from window cache first (may be set by other scripts)
  if (window.allGames && Array.isArray(window.allGames) && window.allGames.length > 0) {
    return window.allGames;
  }

  // Try to get from memory cache
  if (window.cache && window.cache.games && Array.isArray(window.cache.games)) {
    return window.cache.games;
  }

  // Try to get from IndexedDB first before other methods
  try {
    const db = await openIndexedDB();
    if (db) {
      const games = await getAllGamesFromDB(db);
      if (games && games.length > 0) {
        console.log("Retrieving", games.length, "games from IndexedDB");
        return games;
      }
    }
  } catch (e) {
    console.warn('Error loading games from IndexedDB:', e);
  }

  // Try each category cache
  const categories = ['cloud', 'browser', 'emulator'];
  let allGames = [];

  for (const category of categories) {
    if (window.cache && window.cache[category] && Array.isArray(window.cache[category])) {
      allGames = [...allGames, ...window.cache[category]];
    } else {
      // Try localStorage
      try {
        const cachedData = localStorage.getItem(`cache_games_${category}`);
        if (cachedData) {
          const parsed = JSON.parse(cachedData);
          if (parsed.data && Array.isArray(parsed.data)) {
            allGames = [...allGames, ...parsed.data];
          }
        }
      } catch (e) {
        console.warn(`Error loading ${category} games from localStorage:`, e);
      }
    }
  }

  // If we have games, return them
  if (allGames.length > 0) {
    return allGames;
  }

  // Try to get from legacy cache
  try {
    const cachedData = localStorage.getItem('cache_games');
    if (cachedData) {
      const parsed = JSON.parse(cachedData);
      if (parsed.data && Array.isArray(parsed.data)) {
        return parsed.data;
      }
    }
  } catch (e) {
    console.warn('Error loading games from legacy cache:', e);
  }

  // Last resort: fetch from server and store in IndexedDB
  try {
    const response = await fetch('/json/g.json');
    if (!response.ok) throw new Error('Failed to fetch games data');

    const data = await response.json();

    // Ensure each game has a unique ID for IndexedDB storage
    data.forEach((game, index) => {
      if (!game.id) {
        if (game.slug) {
          game.id = game.slug;
        } else if (game.name) {
          game.id = game.name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '-');
        } else {
          game.id = `game-${Math.random().toString(36).substring(2, 7)}`;
        }
      }
      // Store the original index
      game._originalIndex = index;
    });

    // Store in IndexedDB for future use
    try {
      const db = await openIndexedDB();
      if (db) {
        await storeGamesInDB(db, data);
        console.log('Successfully stored games in IndexedDB');
      }
    } catch (e) {
      console.warn('Error storing games in IndexedDB:', e);
    }

    return data;
  } catch (error) {
    console.error('Error fetching games data:', error);
    return [];
  }
}


function updateGameDetails(game, allGames) {
  if (!game) return;

  const gameContainer = document.getElementById('game-container');
  const gameInfoSection = gameContainer.querySelector('.game-info');

  if (!gameInfoSection) return;

  // Clear any loading state
  gameInfoSection.innerHTML = '';

  // Create parallax background
  const parallaxContainer = document.createElement('div');
  parallaxContainer.className = 'game-parallax-container';

  const parallaxBackground = document.createElement('div');
  parallaxBackground.className = 'game-parallax-background';
  parallaxBackground.style.backgroundImage = `url('${game.img || '/assets/game-placeholder.jpg'}')`;

  const imageContainer = document.createElement('div');
  imageContainer.className = 'game-image-container';
  imageContainer.innerHTML = `<img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" class="game-detail-image">`;

  parallaxContainer.appendChild(parallaxBackground);
  parallaxContainer.appendChild(imageContainer);
  gameInfoSection.appendChild(parallaxContainer);

  // Game title
  const title = document.createElement('h1');
  title.textContent = game.name;
  gameInfoSection.appendChild(title);

  // Game tags
  if (game.tags && Array.isArray(game.tags) && game.tags.length > 0) {
    const tagsDiv = document.createElement('div');
    tagsDiv.className = 'game-tags';
    tagsDiv.innerHTML = game.tags.map(tag => `<span class="game-tag">${tag}</span>`).join('');
    gameInfoSection.appendChild(tagsDiv);
  }

  // Game metadata
  const metadataDiv = document.createElement('div');
  metadataDiv.className = 'game-metadata';

  // Category metadata
  metadataDiv.innerHTML += `
    <div class="metadata-item">
      <div class="metadata-icon">
        <i class="fa-solid fa-gamepad"></i>
      </div>
      <div>
        <span class="metadata-label">Category</span>
        <div class="metadata-value">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser'} Game</div>
      </div>
    </div>
  `;

  // Genre metadata (if available)
  if (game.genre) {
    metadataDiv.innerHTML += `
      <div class="metadata-item">
        <div class="metadata-icon">
          <i class="fa-solid fa-tag"></i>
        </div>
        <div>
          <span class="metadata-label">Genre</span>
          <div class="metadata-value">${game.genre}</div>
        </div>
      </div>
    `;
  }

  // Publisher metadata (if available)
  if (game.publisher) {
    metadataDiv.innerHTML += `
      <div class="metadata-item">
        <div class="metadata-icon">
          <i class="fa-solid fa-building"></i>
        </div>
        <div>
          <span class="metadata-label">Publisher</span>
          <div class="metadata-value">${game.publisher}</div>
        </div>
      </div>
    `;
  }

  // Release date metadata (if available)
  if (game.releaseDate) {
    // Format date from YYYY-MM-DD to Month DD, YYYY
    let formattedDate = game.releaseDate;
    try {
      const dateObj = new Date(game.releaseDate);
      formattedDate = dateObj.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });

      // Add ordinal suffix
      formattedDate = formattedDate.replace(/(\d+)/, function (match) {
        const day = parseInt(match);
        if (day > 3 && day < 21) return day + 'th';
        switch (day % 10) {
          case 1: return day + 'st';
          case 2: return day + 'nd';
          case 3: return day + 'rd';
          default: return day + 'th';
        }
      });
    } catch (e) {
      console.warn('Error formatting date:', e);
    }

    metadataDiv.innerHTML += `
    <div class="metadata-item">
      <div class="metadata-icon">
        <i class="fa-solid fa-calendar-days"></i>
      </div>
      <div>
        <span class="metadata-label">Release Date</span>
        <div class="metadata-value">${formattedDate}</div>
      </div>
    </div>
  `;
  }

  gameInfoSection.appendChild(metadataDiv);

  // Game description
  const descriptionDiv = document.createElement('div');
  descriptionDiv.className = 'game-description';
  descriptionDiv.innerHTML = `
    <h3>About ${game.name}</h3>
    <p>${game.description || `${game.name} is a ${game.category || 'browser'} game available to play unblocked at school.`}</p>
    <p>Choose between directly opening the game in a new tab or using our secure Flamepass Proxy which
        can help bypass additional restrictions. The proxy option requires a Flamepass account and
        works on school devices.</p>
    <p>For the best experience, we recommend using the Flamepass Proxy option which helps evade content
        filtering systems and keeps your gaming activities private.</p>
  `;
  gameInfoSection.appendChild(descriptionDiv);

  // Game buttons - only for browser and emulator games, not for cloud games
  if (game.category !== 'cloud') {
    const buttonsDiv = document.createElement('div');
    buttonsDiv.className = 'game-buttons';
    buttonsDiv.innerHTML = `
      <a href="${game.url || '#'}" class="play-button" id="openGameBtn" data-game-url="${game.url || '#'}">
        <i class="fa-solid fa-play"></i>
        Play Now
      </a>
      <a href="#" class="proxy-button" id="proxyGameBtn" data-game-url="${game.url || '#'}">
        <i class="fa-solid fa-shield-halved"></i>
        Play with Flamepass Proxy
      </a>
    `;
    gameInfoSection.appendChild(buttonsDiv);
  }
}
// Update setupButtonHandlers function to handle nettleweb.com emulator games
function setupButtonHandlers(game) {
  if (!game) return;

  // Direct play button
  const openGameBtn = document.getElementById('openGameBtn');
  if (openGameBtn) {
    openGameBtn.addEventListener('click', (e) => {
      // Check if this is a nettleweb.com emulator game
      if (game.category === 'emulator' && game.url && game.url.includes('nettleweb.com')) {
        e.preventDefault();

        // Create and show modal with direct URL
        createIframeModal(game.url);

        // Track play action for analytics
        if (window.gtag) {
          gtag('event', 'play_game', {
            'game_name': game.name,
            'game_category': game.category,
            'method': 'direct'
          });
        }
      } else {
        // Normal behavior for other games
        if (window.gtag) {
          gtag('event', 'play_game', {
            'game_name': game.name,
            'game_category': game.category,
            'method': 'direct'
          });
        }
      }
    });
  }

  // Proxy play button
  const proxyGameBtn = document.getElementById('proxyGameBtn');
  if (proxyGameBtn) {
    proxyGameBtn.addEventListener('click', (e) => {
      e.preventDefault();

      // Get game URL from data attribute
      const gameUrl = proxyGameBtn.getAttribute('data-game-url');

      // Check if this is a nettleweb.com emulator game
      if (game.category === 'emulator' && gameUrl && gameUrl.includes('nettleweb.com')) {
        // Check if user is logged in (using auth-controller.js function)
        const isLoggedIn = window.isLoggedIn ? window.isLoggedIn() : false;

        if (isLoggedIn) {
          // Create and show modal with proxy URL
          const proxyUrl = `https://app.flamepass.com/@/index.html?uul=${encodeURIComponent(gameUrl)}`;
          createIframeModal(proxyUrl);

          // Track play action for analytics
          if (window.gtag) {
            gtag('event', 'play_game', {
              'game_name': game.name,
              'game_category': game.category,
              'method': 'proxy'
            });
          }
        } else {
          // User is not logged in, show auth modal from auth-controller.js
          if (window.showAuthModal) {
            window.showAuthModal();
          } else if (window.showLoginPopup) {
            window.showLoginPopup();
          }

          // Track auth prompt
          if (window.gtag) {
            gtag('event', 'auth_prompt', {
              'trigger': 'proxy_play',
              'game_name': game.name
            });
          }
        }
      } else {
        // Standard proxy behavior for other games
        const isLoggedIn = window.isLoggedIn ? window.isLoggedIn() : false;

        if (isLoggedIn) {
          // User is logged in, redirect to proxy
          window.open(`/@/index.html?uul=${encodeURIComponent(gameUrl)}`, '_blank');

          // Track play action for analytics
          if (window.gtag) {
            gtag('event', 'play_game', {
              'game_name': game.name,
              'game_category': game.category,
              'method': 'proxy'
            });
          }
        } else {
          // User is not logged in, show auth modal from auth-controller.js
          if (window.showAuthModal) {
            window.showAuthModal();
          } else if (window.showLoginPopup) {
            window.showLoginPopup();
          }

          // Track auth prompt
          if (window.gtag) {
            gtag('event', 'auth_prompt', {
              'trigger': 'proxy_play',
              'game_name': game.name
            });
          }
        }
      }
    });
  }
}

// Update cloud provider proxy buttons to use the global auth system
function setupCloudProviders(game) {
  if (!game || !game.serviceProviders) return;

  const providersContainer = document.getElementById('cloud-providers-container');
  const providersGrid = document.getElementById('providers-grid');

  if (!providersContainer || !providersGrid) return;

  // Clear existing providers
  providersGrid.innerHTML = '';

  // Loop through each service provider
  Object.entries(game.serviceProviders).forEach(([provider, info]) => {
    const providerCard = document.createElement('div');
    providerCard.className = 'provider-card';

    // Set logo path based on provider name
    const logoPath = `/assets/providers/${provider.toLowerCase()}.png`;

    // Build provider card according to paste.txt template
    providerCard.innerHTML = `
      <div class="provider-logo">
        <img src="${logoPath}" alt="${provider}" onerror="this.src='/assets/logo.webp'">
      </div>
      <h3 class="provider-name">${provider}</h3>
      <div class="provider-buttons">
        <a href="${info.url}" target="_blank" class="provider-direct-button">
          <i class="fa-solid fa-external-link-alt"></i>
          Direct
        </a>
        <a href="#" class="provider-proxy-button" data-url="${encodeURIComponent(info.url)}">
          <i class="fa-solid fa-shield-alt"></i>
          Proxy
        </a>
      </div>
    `;

    providersGrid.appendChild(providerCard);
  });

  // Add event listeners to proxy buttons
  const proxyButtons = providersGrid.querySelectorAll('.provider-proxy-button');
  proxyButtons.forEach(button => {
    button.addEventListener('click', (e) => {
      e.preventDefault();

      // Get provider URL
      const providerUrl = button.getAttribute('data-url');

      // Check if user is logged in
      const isLoggedIn = window.isLoggedIn ? window.isLoggedIn() : false;

      if (isLoggedIn) {
        // User is logged in, redirect to proxy
        window.open(`/@/index.html?uul=${providerUrl}`, '_blank');
      } else {
        // User is not logged in, show auth modal from auth-controller.js
        if (window.showAuthModal) {
          window.showAuthModal();
        } else if (window.showLoginPopup) {
          window.showLoginPopup();
        }
      }
    });
  });

  // Show the providers section
  providersContainer.style.display = game.category === 'cloud' ? 'block' : 'none';
}

async function initGamePage(slug) {
  if (!slug) return;

  try {
    // Show loading state
    showLoading();

    // Get game data
    const allGames = await fetchGames();
    const currentGame = allGames.find(game => game.slug === slug);

    // Store game data globally for other scripts
    window.currentGame = currentGame;
    window.allGames = allGames;

    if (!currentGame) {
      showError('Game Not Found', 'Sorry, we couldn\'t find the game you\'re looking for.');
      return;
    }

    // Update document title
    document.title = `Play ${currentGame.name} Unblocked on Flamepass`;

    // Update meta tags for SEO
    updateMetaTags(currentGame);

    // Update game details in the existing container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      updateGameDetails(currentGame, allGames);
    }

    // Setup button event handlers
    setupButtonHandlers(currentGame);

    // Setup cloud provider buttons if applicable
    if (currentGame.category === 'cloud' && currentGame.serviceProviders) {
      setupCloudProviders(currentGame);
    }

    // Initialize parallax effect
    initParallaxEffect();

    // Initialize unblock tips section - ADD THIS LINE
    initUnblockTipsSection();

    // Initialize components with all categories
    const categories = ['browser', 'emulator', 'cloud'];
    const currentCategory = currentGame.category || 'browser';

    // First show games from the same category
    updateCategoryBasedGames(currentGame, allGames, currentCategory);

    // Then show trending games
    updateTrendingGames(allGames);

    // Then show games from other categories
    categories.forEach(category => {
      if (category !== currentCategory) {
        updateCategoryGames(currentGame, allGames, category);
      }
    });

  } catch (error) {
    console.error('Error initializing game page:', error);
    showError('Error Loading Game', 'There was a problem loading the game details. Please try again later.');
  }
}

function updateMetaTags(game) {
  // Update meta description
  const metaDescription = document.querySelector('meta[name="description"]');
  if (metaDescription) {
    metaDescription.setAttribute('content',
      `Play ${game.name} unblocked at school with Flamepass, the next gen school proxy. No downloads required, bypasses school filters, works directly in your browser.`
    );
  }

  // Update meta keywords
  const metaKeywords = document.querySelector('meta[name="keywords"]');
  if (metaKeywords) {
    metaKeywords.setAttribute('content',
      `Unblocked Games, School Games, ${game.name} Unblocked, Bypass School Filters, Flamepass`
    );
  }

  // Update og:title
  const ogTitle = document.querySelector('meta[property="og:title"]');
  if (ogTitle) {
    ogTitle.setAttribute('content', `Play ${game.name} Unblocked | Flamepass`);
  }

  // Update canonical URL
  const canonical = document.querySelector('link[rel="canonical"]');
  if (canonical) {
    canonical.setAttribute('href', `/game/${game.slug}`);
  }
}
function initParallaxEffect() {
  const parallaxBackground = document.querySelector('.game-parallax-background');
  if (!parallaxBackground) return;

  // Add scroll event listener for parallax effect
  window.addEventListener('scroll', () => {
    const scrollPosition = window.scrollY;
    const translateY = Math.min(scrollPosition * 0.2, 100); // Limit max translation

    // Apply parallax effect
    parallaxBackground.style.transform = `translateY(${translateY}px)`;
    parallaxBackground.style.opacity = Math.max(1 - (scrollPosition * 0.002), 0.3); // Fade out slightly on scroll
  });
}

function initializeParticles() {
  if (window.particlesJS && document.getElementById('particles-js')) {
    particlesJS('particles-js', {
      particles: {
        number: { value: 80, density: { enable: true, value_area: 800 } },
        color: { value: '#ffffff' },
        shape: { type: 'circle' },
        opacity: { value: 0.5, random: true },
        size: { value: 3, random: true },
        line_linked: { enable: false },
        move: {
          enable: true,
          speed: 0.3,
          direction: 'top',
          random: true,
          straight: false,
          out_mode: 'out'
        }
      }
    });
  }
}

function showLoading() {
  const gameInfoSection = document.querySelector('.game-info');
  if (!gameInfoSection) return;

  gameInfoSection.innerHTML = `
    <div class="loading-container">
      <div class="game-loader">
        <svg viewBox="0 0 80 80">
          <circle cx="40" cy="40" r="32" class="loader-circle"></circle>
        </svg>
      </div>
      <h2 class="loading-text">Loading Game Details</h2>
      <p class="loading-subtext">Preparing your unblocked gaming experience...</p>
    </div>
  `;
}

function showError(title, message) {
  const gameContainer = document.getElementById('game-container');
  if (!gameContainer) return;

  // Update the first element with error message
  const firstElement = gameContainer.firstElementChild;
  if (firstElement) {
    firstElement.innerHTML = `
      <div class="error-message">
        <span class="material-symbols-outlined">error</span>
        <h3>${title}</h3>
        <p>${message}</p>
        <a href="/g.html" class="retry-button">
          <i class="fa-solid fa-gamepad"></i>
          Browse All Games
        </a>
      </div>
    `;
  }
}

// Add a function to create and display the iframe modal
function createIframeModal(url) {
  // Create modal container
  const modal = document.createElement('div');
  modal.className = 'iframe-modal';
  modal.style.position = 'fixed';
  modal.style.top = '0';
  modal.style.left = '0';
  modal.style.width = '100%';
  modal.style.height = '100%';
  modal.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
  modal.style.zIndex = '9999';
  modal.style.display = 'flex';
  modal.style.justifyContent = 'center';
  modal.style.alignItems = 'center';

  // Create modal content
  const modalContent = document.createElement('div');
  modalContent.className = 'iframe-modal-content';
  modalContent.style.position = 'relative';
  modalContent.style.width = '1280px';
  modalContent.style.height = '720px';
  modalContent.style.maxWidth = '95%';
  modalContent.style.maxHeight = '90%';

  // Create close button
  const closeBtn = document.createElement('button');
  closeBtn.className = 'iframe-modal-close';
  closeBtn.innerHTML = '&times;';
  closeBtn.style.position = 'absolute';
  closeBtn.style.top = '-40px';
  closeBtn.style.right = '0';
  closeBtn.style.backgroundColor = 'red';
  closeBtn.style.color = 'white';
  closeBtn.style.border = 'none';
  closeBtn.style.borderRadius = '50%';
  closeBtn.style.width = '32px';
  closeBtn.style.height = '32px';
  closeBtn.style.fontSize = '20px';
  closeBtn.style.cursor = 'pointer';
  closeBtn.style.display = 'flex';
  closeBtn.style.justifyContent = 'center';
  closeBtn.style.alignItems = 'center';
  closeBtn.style.zIndex = '10000';

  // Create iframe
  const iframe = document.createElement('embed');
  iframe.type = 'text/plain';
  iframe.width = '1280';
  iframe.height = '720';
  iframe.style.border = 'none';
  iframe.style.maxWidth = '100%';
  iframe.style.maxHeight = '100%';
  iframe.src = url;

  // Add elements to DOM
  modalContent.appendChild(closeBtn);
  modalContent.appendChild(iframe);
  modal.appendChild(modalContent);
  document.body.appendChild(modal);

  // Prevent body scrolling when modal is open
  document.body.style.overflow = 'hidden';

  // Add event listener to close button
  closeBtn.addEventListener('click', () => {
    document.body.removeChild(modal);
    document.body.style.overflow = '';
  });

  // Close modal when clicking outside iframe
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
      document.body.style.overflow = '';
    }
  });
}


function initializeDynamicComponents(currentGame) {
  // Initialize parallax effect
  initParallaxEffect();

  // Initialize unblock tips section - ADD THIS LINE
  initUnblockTipsSection();

  // Add event listeners to buttons
  setupButtonHandlers(currentGame);

  // Setup cloud provider buttons if applicable
  if (currentGame.category === 'cloud' && currentGame.serviceProviders) {
    setupCloudProviders(currentGame);
  }

  // Fetch all games for related content
  fetchGames().then(allGames => {
    // Store games data for other scripts
    window.allGames = allGames;

    // Update related games sections based on categories
    const categories = ['browser', 'emulator', 'cloud'];
    const currentCategory = currentGame.category || 'browser';

    // First show games from the same category
    updateCategoryBasedGames(currentGame, allGames, currentCategory);

    // Then show trending games
    updateTrendingGames(allGames);

    // Then show games from other categories
    categories.forEach(category => {
      if (category !== currentCategory) {
        updateCategoryGames(currentGame, allGames, category);
      }
    });

  }).catch(error => {
    console.error('Error fetching games for dynamic components:', error);
  });
}

function getRandomGames(games, count) {
  if (!Array.isArray(games) || games.length === 0) {
    return [];
  }

  // Shuffle array
  const shuffled = [...games].sort(() => 0.5 - Math.random());

  // Return up to count games
  return shuffled.slice(0, Math.min(count, shuffled.length));
}

function updateGameGrid(grid, games) {
  if (!grid || !Array.isArray(games)) return;

  // Clear grid first
  grid.innerHTML = '';

  // Add game cards to grid
  games.forEach(game => {
    const gameCard = document.createElement('a');
    gameCard.href = `/game/${game.slug}`;
    gameCard.className = 'game-card';

    gameCard.innerHTML = `
      <div class="game-card-image">
        <img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" loading="lazy">
      </div>
      <div class="game-card-info">
        <h3>${game.name}</h3>
        <div class="game-card-meta">
          <span class="category-pill">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser'}</span>
        </div>
      </div>
    `;

    grid.appendChild(gameCard);
  });
}

function updateCategoryBasedGames(game, allGames, category) {
  if (!game || !allGames || !category) return;

  // Create container if not exists
  let container = document.querySelector('.category-games-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'category-games-container';

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // Filter games from the same category, but not the current game
  const categoryGames = allGames.filter(g =>
    g.category === category && g.slug !== game.slug
  );

  // If no games, hide container
  if (categoryGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games from category (up to 4)
  const gamesToShow = getRandomGames(categoryGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';
  header.innerHTML = `
    <h2>More ${category.charAt(0).toUpperCase() + category.slice(1)} Games</h2>
    <a href="/g.html?category=${category}" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}
function updateTrendingGames(allGames) {
  if (!allGames) return;

  // Create container if not exists
  let container = document.querySelector('.trending-games-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'trending-games-container';

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // If no games, hide container
  if (allGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games (up to 4) - in a real app, this would be most popular
  const gamesToShow = getRandomGames(allGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';
  header.innerHTML = `
    <h2>Trending Games</h2>
    <a href="/g.html?trending=true" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}

function updateCategoryGames(game, allGames, category) {
  if (!game || !allGames || !category) return;

  // Create container if not exists
  let container = document.querySelector(`.${category}-games-container`);
  if (!container) {
    container = document.createElement('div');
    container.className = `${category}-games-container`;

    // Add to game container
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) {
      gameContainer.appendChild(container);
    } else {
      document.body.appendChild(container);
    }
  }

  // Clear container
  container.innerHTML = '';

  // Filter games from the specific category, but not the current game
  const categoryGames = allGames.filter(g =>
    g.category === category && g.slug !== game.slug
  );

  // If no games, hide container
  if (categoryGames.length === 0) {
    container.style.display = 'none';
    return;
  }

  // Get random games from category (up to 4)
  const gamesToShow = getRandomGames(categoryGames, 4);

  // Create section header
  const header = document.createElement('div');
  header.className = 'section-header-container';

  // Customize title based on category
  let title;
  switch (category) {
    case 'browser':
      title = 'HTML5 Browser Games';
      break;
    case 'emulator':
      title = 'Emulator Games';
      break;
    case 'cloud':
      title = 'Cloud Gaming';
      break;
    default:
      title = `${category.charAt(0).toUpperCase() + category.slice(1)} Games`;
  }

  header.innerHTML = `
    <h2>${title}</h2>
    <a href="/g.html?category=${category}" class="view-all-link">
      View All <span class="material-symbols-outlined">arrow_forward</span>
    </a>
  `;
  container.appendChild(header);

  // Create grid container
  const gridContainer = document.createElement('div');
  gridContainer.className = 'games-grid-container';
  container.appendChild(gridContainer);

  // Create grid with games
  const grid = document.createElement('div');
  grid.className = 'games-grid';
  gridContainer.appendChild(grid);

  // Update grid with games
  updateGameGrid(grid, gamesToShow);

  // Show container
  container.style.display = 'block';
}
function initSearch() {
  const searchTrigger = document.getElementById('searchTrigger');
  const searchModal = document.getElementById('searchModal');
  const closeSearch = document.getElementById('closeSearch');
  const searchInput = document.getElementById('searchInput');
  const searchResults = document.getElementById('searchResults');

  if (!searchTrigger || !searchModal || !closeSearch || !searchInput || !searchResults) {
    console.warn('Search elements not found. Search functionality disabled.');
    return;
  }

  // Open search modal
  searchTrigger.addEventListener('click', () => {
    openSearchModal();
  });

  // Close search modal
  closeSearch.addEventListener('click', () => {
    closeSearchModal();
  });

  // Click outside to close
  searchModal.addEventListener('click', (e) => {
    if (e.target === searchModal) {
      closeSearchModal();
    }
  });

  // Search input handler with debounce
  let debounceTimer;
  searchInput.addEventListener('input', () => {
    clearTimeout(debounceTimer);

    const query = searchInput.value.trim();

    if (query.length < 2) {
      searchResults.innerHTML = `
        <div class="search-message">
          <span class="material-symbols-outlined">search</span>
          <p>Type at least 2 characters to search</p>
        </div>
      `;
      return;
    }

    // Set loading state
    searchResults.innerHTML = `
      <div class="search-message">
        <div class="loader" style="width: 30px; height: 30px;">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="32" class="loader-circle" />
          </svg>
        </div>
        <p>Searching...</p>
      </div>
    `;

    // Debounce search request
    debounceTimer = setTimeout(() => {
      performSearch(query.toLowerCase());
    }, 300);
  });
}

function openSearchModal() {
  const searchModal = document.getElementById('searchModal');
  const searchInput = document.getElementById('searchInput');

  if (!searchModal || !searchInput) return;

  searchModal.classList.add('active');

  // Focus input after animation
  setTimeout(() => {
    searchInput.focus();
  }, 100);

  // Disable body scroll
  document.body.style.overflow = 'hidden';
}

function closeSearchModal() {
  const searchModal = document.getElementById('searchModal');
  const searchInput = document.getElementById('searchInput');

  if (!searchModal || !searchInput) return;

  searchModal.classList.remove('active');
  searchInput.value = '';

  // Enable body scroll
  document.body.style.overflow = '';
}
async function performSearch(query) {
  const searchResults = document.getElementById('searchResults');

  if (!searchResults) return;

  try {
    // Get all games
    const allGames = await fetchGames();

    console.log(`Searching through ${allGames.length} games for "${query}"`);

    // Filter games based on query
    const filteredGames = allGames.filter(game =>
      (game.name && game.name.toLowerCase().includes(query)) ||
      (game.description && game.description.toLowerCase().includes(query)) ||
      (game.category && game.category.toLowerCase().includes(query)) ||
      (game.publisher && game.publisher.toLowerCase().includes(query)) ||
      (game.tags && Array.isArray(game.tags) && game.tags.some(tag => tag.toLowerCase().includes(query)))
    );

    // Display results
    if (filteredGames.length === 0) {
      searchResults.innerHTML = `
        <div class="search-message">
          <span class="material-symbols-outlined">sentiment_dissatisfied</span>
          <p>No games found matching "${query}"</p>
        </div>
      `;
    } else {
      searchResults.innerHTML = '';

      filteredGames.slice(0, 8).forEach(game => {
        const resultItem = document.createElement('a');
        resultItem.href = `/game/${game.slug}`;
        resultItem.className = 'search-result-item';

        resultItem.innerHTML = `
          <div class="search-result-image">
            <img src="${game.img || '/assets/game-placeholder.jpg'}" alt="${game.name}" loading="lazy">
          </div>
          <div class="search-result-info">
            <h3>${game.name}</h3>
            <div class="search-result-meta">
              <span class="category-pill">${game.category ? game.category.charAt(0).toUpperCase() + game.category.slice(1) : 'Browser Game'}</span>
              ${game.publisher ? `<span class="publisher">${game.publisher}</span>` : ''}
            </div>
          </div>
        `;

        searchResults.appendChild(resultItem);
      });

      if (filteredGames.length > 8) {
        const viewAll = document.createElement('a');
        viewAll.href = `/g.html?search=${encodeURIComponent(query)}`;
        viewAll.className = 'view-all-results';
        viewAll.innerHTML = `View all ${filteredGames.length} results <span class="material-symbols-outlined">arrow_forward</span>`;
        searchResults.appendChild(viewAll);
      }
    }
  } catch (error) {
    console.error('Error during search:', error);
    searchResults.innerHTML = `
      <div class="search-message">
        <span class="material-symbols-outlined">error</span>
        <p>An error occurred while searching</p>
      </div>
    `;
  }
}
function initScrollToTop() {
  const scrollTopBtn = document.getElementById('scrollTopBtn');

  if (!scrollTopBtn) return;

  // Show/hide button based on scroll position
  window.addEventListener('scroll', () => {
    if (document.documentElement.scrollTop > 300) {
      scrollTopBtn.classList.add('visible');
    } else {
      scrollTopBtn.classList.remove('visible');
    }
  });

  // Scroll to top when clicked
  scrollTopBtn.addEventListener('click', () => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  });
}

function setupKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    // Open search with Cmd+K or Ctrl+K
    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
      e.preventDefault();
      openSearchModal();
    }

    // Close search with Escape
    if (e.key === 'Escape') {
      closeSearchModal();

      // Also close auth modal if open
      const authModal = document.getElementById('authModal');
      if (authModal && authModal.classList.contains('active')) {
        authModal.classList.remove('active');
      }
    }
  });
}

function initUnblockTipsSection() {
  const unblockInfoSection = document.querySelector('.unblock-info-section');

  if (!unblockInfoSection) return;

  // Clear any placeholder content
  unblockInfoSection.innerHTML = '';

  // Create header
  const header = document.createElement('h2');
  header.textContent = 'How to Play Games Unblocked at School';
  unblockInfoSection.appendChild(header);

  // Create description
  const description = document.createElement('p');
  description.textContent = 'Flamepass provides multiple ways to access blocked content at school or work. Here are some tips to enhance your experience:';
  unblockInfoSection.appendChild(description);

  // Create tips container
  const tipsContainer = document.createElement('div');
  tipsContainer.className = 'unblock-tips';

  // Define tips (3 with more useful information)
  const tips = [
    {
      icon: 'fa-shield',
      title: 'Use Flamepass Proxy',
      description: 'Our secure proxy can bypass most school filters and keeps your gaming activity hidden from monitoring systems. For fresh alternate links, check our <a href="/ultimate-links.html">Ultimate Links</a> page.'
    },
    {
      icon: 'fa-clock',
      title: 'Try Alternative Links',
      description: 'If the main site gets blocked, use our <a href="/links.html">Link Generator</a> for fresh domains. Join our Discord server for the latest working links and updates.'
    },
    {
      icon: 'fa-bolt',
      title: 'Use About:Blank Cloaking',
      description: 'Launch games through an about:blank page to hide the actual URL from basic monitoring systems. This method helps prevent detection by school web filters.'
    }
  ];

  // Add tips to container
  tips.forEach(tip => {
    const tipCard = document.createElement('div');
    tipCard.className = 'tip-card';

    tipCard.innerHTML = `
      <div class="tip-icon">
        <i class="fa-solid ${tip.icon}"></i>
      </div>
      <h3 class="tip-title">${tip.title}</h3>
      <p class="tip-description">${tip.description}</p>
    `;

    tipsContainer.appendChild(tipCard);
  });

  unblockInfoSection.appendChild(tipsContainer);

  // Add advanced tips section
  const advancedTips = document.createElement('div');
  advancedTips.className = 'advanced-tips';

  advancedTips.innerHTML = `
    <h3>Advanced Unblocking Methods</h3>
    <div class="advanced-tips-grid">
      <div class="advanced-tip">
        <div class="advanced-tip-icon">
          <i class="fa-solid fa-gamepad"></i>
        </div>
        <div class="advanced-tip-content">
          <h4>WebGL & HTML5 Games</h4>
          <p>Focus on WebGL-based games like Krunker.io and Shell Shockers that often work even on restricted networks. Check our <a href="/g.html?category=browser">Browser Games</a> section.</p>
        </div>
      </div>
      
      <div class="advanced-tip">
        <div class="advanced-tip-icon">
          <i class="fa-solid fa-server"></i>
        </div>
        <div class="advanced-tip-content">
          <h4>Create Your Own Link</h4>
          <p>Make your own proxy links with FreeDNS or Vercel for maximum privacy. Visit our <a href="/guides.html">Guides</a> page for step-by-step instructions.</p>
        </div>
      </div>
      
      <div class="advanced-tip">
        <div class="advanced-tip-icon">
          <i class="fa-solid fa-window-restore"></i>
        </div>
        <div class="advanced-tip-content">
          <h4>Discord Servers</h4>
          <p>Join proxy Discord servers like Interstellar or Mercury Workshop to get fresh links that bypass filters. Check our <a href="/discord.html">Discord</a> page for more info.</p>
        </div>
      </div>
    </div>
  `;

  unblockInfoSection.appendChild(advancedTips);
}